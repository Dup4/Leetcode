{"slug":"distinct-subsequences","id":115,"frontendId":115,"title":"Distinct Subsequences","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":718,"dislikes":0,"status":2,"tag":[{"name":"String","slug":"string","translatedName":"字符串"},{"name":"Dynamic Programming","slug":"dynamic-programming","translatedName":"动态规划"}],"totalAccepted":79910,"totalSubmission":154172,"hints":[],"sampleTestCase":"\"rabbbit\"\n\"rabbit\"","exampleTestcases":"\"rabbbit\"\n\"rabbit\"\n\"babgbag\"\n\"bag\"","content":"<p>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code> which equals <code>t</code></em>.</p>\n\n<p>A string&#39;s <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters&#39; relative positions. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>\n\n<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nAs shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code>\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babgbag&quot;, t = &quot;bag&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nAs shown below, there are 5 ways you can generate &quot;bag&quot; from S.\n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code></pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> and <code>t</code> consist of English letters.</li>\n</ul>\n","translatedContent":"<p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>\"ACE\"</code> 是 <code>\"ABCDE\"</code> 的一个子序列，而 <code>\"AEC\"</code> 不是）</p>\n\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"rabbbit\", t = \"rabbit\"<code>\n<strong>输出</strong></code><strong>：</strong><code>3\n</code><strong>解释：</strong>\n如下图所示, 有 3 种可以从 s 中得到 <code>\"rabbit\" 的方案</code>。\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babgbag\", t = \"bag\"\n<code><strong>输出</strong></code><strong>：</strong><code>5\n</code><strong>解释：</strong>\n如下图所示, 有 5 种可以从 s 中得到 <code>\"bag\" 的方案</code>。 \n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code>\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length, t.length <= 1000</code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n","translatedTitle":"不同的子序列","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int numDistinct(string s, string t) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int numDistinct(String s, String t) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint numDistinct(char * s, char * t){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int NumDistinct(string s, string t) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {String} s\n# @param {String} t\n# @return {Integer}\ndef num_distinct(s, t)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func numDistinct(_ s: String, _ t: String) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func numDistinct(s string, t string) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def numDistinct(s: String, t: String): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun numDistinct(s: String, t: String): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn num_distinct(s: String, t: String) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Integer\n     */\n    function numDistinct($s, $t) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function numDistinct(s: string, t: string): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (num-distinct s t)\n  (-> string? string? exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec num_distinct(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> integer().\nnum_distinct(S, T) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec num_distinct(s :: String.t, t :: String.t) :: integer\n  def num_distinct(s, t) do\n\n  end\nend"}]}