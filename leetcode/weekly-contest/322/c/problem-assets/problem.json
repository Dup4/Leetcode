{"slug":"minimum-score-of-a-path-between-two-cities","id":2582,"frontendId":6255,"title":"Minimum Score of a Path Between Two Cities","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":6,"dislikes":0,"status":2,"tag":[],"totalAccepted":3787,"totalSubmission":10528,"hints":["Can you solve the problem if the whole graph is connected?","Notice that if the graph is connected, you can always use any edge of the graph in your path.","How to solve the general problem in a similar way? Remove all the nodes that are not connected to 1 and n, then apply the previous solution in the new graph."],"sampleTestCase":"4\n[[1,2,9],[2,3,6],[2,4,5],[1,4,7]]","exampleTestcases":"4\n[[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n4\n[[1,2,2],[1,3,4],[3,4,7]]","content":"<p>You are given a positive integer <code>n</code> representing <code>n</code> cities numbered from <code>1</code> to <code>n</code>. You are also given a <strong>2D</strong> array <code>roads</code> where <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code> indicates that there is a <strong>bidirectional </strong>road between cities <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with a distance equal to <code>distance<sub>i</sub></code>. The cities graph is not necessarily connected.</p>\n\n<p>The <strong>score</strong> of a path between two cities is defined as the <strong>minimum </strong>distance of a road in this path.</p>\n\n<p>Return <em>the <strong>minimum </strong>possible score of a path between cities </em><code>1</code><em> and </em><code>n</code>.</p>\n\n<p><strong>Note</strong>:</p>\n\n<ul>\n\t<li>A path is a sequence of roads between two cities.</li>\n\t<li>It is allowed for a path to contain the same road <strong>multiple</strong> times, and you can visit cities <code>1</code> and <code>n</code> multiple times along the path.</li>\n\t<li>The test cases are generated such that there is <strong>at least</strong> one path between <code>1</code> and <code>n</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-10-12-graph11.png\" style=\"width: 190px; height: 231px;\" />\n<pre>\n<strong>Input:</strong> n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-10-12-graph22.png\" style=\"width: 190px; height: 231px;\" />\n<pre>\n<strong>Input:</strong> n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The path from city 1 to 4 with the minimum score is: 1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4. The score of this path is min(2,2,4,7) = 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>There are no repeated edges.</li>\n\t<li>There is at least one path between <code>1</code> and <code>n</code>.</li>\n</ul>\n","translatedContent":"<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示总共有&nbsp;<code>n</code>&nbsp;个城市，城市从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;编号。给你一个二维数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条 <strong>双向</strong>&nbsp;道路，道路距离为&nbsp;<code>distance<sub>i</sub></code>&nbsp;。城市构成的图不一定是连通的。</p>\n\n<p>两个城市之间一条路径的 <strong>分数</strong>&nbsp;定义为这条路径中道路的 <strong>最小</strong>&nbsp;距离。</p>\n\n<p><span class=\"text-only\" data-eleid=\"20\" style=\"white-space: pre;\">城市</span><span class=\"text-only text-font-italic\" data-eleid=\"21\" style=\"white-space: pre;\"> </span><code><span class=\"text-only\" data-eleid=\"22\" style=\"white-space: pre;\">1</span></code><span class=\"text-only text-font-italic\" data-eleid=\"23\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"24\" style=\"white-space: pre;\">和城市</span><span class=\"text-only text-font-italic\" data-eleid=\"25\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"26\" style=\"white-space: pre;\"><code>n</code> 之间的所有路径的 </span><strong><span class=\"text-only\" data-eleid=\"27\" style=\"white-space: pre;\">最小</span></strong><span class=\"text-only\" data-eleid=\"28\" style=\"white-space: pre;\"> 分数。</span></p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一条路径指的是两个城市之间的道路序列。</li>\n\t<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;。</li>\n\t<li>测试数据保证城市 <code>1</code>&nbsp;和城市<code>n</code>&nbsp;之间 <strong>至少</strong>&nbsp;有一条路径。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-10-12-graph11.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n<b>输出：</b>5\n<b>解释：</b>城市 1 到城市 4 的路径中，分数最小的一条为：1 -&gt; 2 -&gt; 4 。这条路径的分数是 min(9,5) = 5 。\n不存在分数更小的路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-10-12-graph22.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n<b>输出：</b>2\n<b>解释：</b>城市 1 到城市 4 分数最小的路径是：1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 。这条路径的分数是 min(2,2,4,7) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>不会有重复的边。</li>\n\t<li>城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;之间至少有一条路径。</li>\n</ul>\n","translatedTitle":"两个城市间路径的最小分数","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int minScore(int n, vector<vector<int>>& roads) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int minScore(int n, int[][] roads) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def minScore(self, n, roads):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def minScore(self, n: int, roads: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"int minScore(int n, int** roads, int roadsSize, int* roadsColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MinScore(int n, int[][] roads) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number} n\n * @param {number[][]} roads\n * @return {number}\n */\nvar minScore = function(n, roads) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer} n\n# @param {Integer[][]} roads\n# @return {Integer}\ndef min_score(n, roads)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func minScore(n int, roads [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def minScore(n: Int, roads: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $roads\n     * @return Integer\n     */\n    function minScore($n, $roads) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function minScore(n: number, roads: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (min-score n roads)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec min_score(N :: integer(), Roads :: [[integer()]]) -> integer().\nmin_score(N, Roads) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec min_score(n :: integer, roads :: [[integer]]) :: integer\n  def min_score(n, roads) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"class Solution {\n  int minScore(int n, List<List<int>> roads) {\n\n  }\n}"}]}