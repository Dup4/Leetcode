{"slug":"count-integers-in-intervals","id":2357,"frontendId":6066,"title":"Count Integers in Intervals","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":1,"dislikes":0,"status":0,"tag":[],"totalAccepted":782,"totalSubmission":6250,"hints":["How can you efficiently add intervals to the set of intervals? Can a data structure like a Binary Search Tree help?","How can you ensure that the intervals present in the set are non-overlapping? Try merging the overlapping intervals whenever a new interval is added.","How can you update the count of integers present in at least one interval when a new interval is added to the set?"],"sampleTestCase":"[\"CountIntervals\",\"add\",\"add\",\"count\",\"add\",\"count\"]\n[[],[2,3],[7,10],[],[5,8],[]]","exampleTestcases":"[\"CountIntervals\",\"add\",\"add\",\"count\",\"add\",\"count\"]\n[[],[2,3],[7,10],[],[5,8],[]]","content":"<p>Given an <strong>empty</strong> set of intervals, implement a data structure that can:</p>\n\n<ul>\n\t<li><strong>Add</strong> an interval to the set of intervals.</li>\n\t<li><strong>Count</strong> the number of integers that are present in <strong>at least one</strong> interval.</li>\n</ul>\n\n<p>Implement the <code>CountIntervals</code> class:</p>\n\n<ul>\n\t<li><code>CountIntervals()</code> Initializes the object with an empty set of intervals.</li>\n\t<li><code>void add(int left, int right)</code> Adds the interval <code>[left, right]</code> to the set of intervals.</li>\n\t<li><code>int count()</code> Returns the number of integers that are present in <strong>at least one</strong> interval.</li>\n</ul>\n\n<p><strong>Note</strong> that an interval <code>[left, right]</code> denotes all the integers <code>x</code> where <code>left &lt;= x &lt;= right</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;CountIntervals&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]\n[[], [2, 3], [7, 10], [], [5, 8], []]\n<strong>Output</strong>\n[null, null, null, 6, null, 8]\n\n<strong>Explanation</strong>\nCountIntervals countIntervals = new CountIntervals(); // initialize the object with an empty set of intervals. \ncountIntervals.add(2, 3);  // add [2, 3] to the set of intervals.\ncountIntervals.add(7, 10); // add [7, 10] to the set of intervals.\ncountIntervals.count();    // return 6\n                           // the integers 2 and 3 are present in the interval [2, 3].\n                           // the integers 7, 8, 9, and 10 are present in the interval [7, 10].\ncountIntervals.add(5, 8);  // add [5, 8] to the set of intervals.\ncountIntervals.count();    // return 8\n                           // the integers 2 and 3 are present in the interval [2, 3].\n                           // the integers 5 and 6 are present in the interval [5, 8].\n                           // the integers 7 and 8 are present in the intervals [5, 8] and [7, 10].\n                           // the integers 9 and 10 are present in the interval [7, 10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls <strong>in total</strong> will be made to <code>add</code> and <code>count</code>.</li>\n\t<li>At least <strong>one</strong> call will be made to <code>count</code>.</li>\n</ul>\n","translatedContent":"<p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p>\n\n<ul>\n\t<li><strong>新增：</strong>添加一个区间到这个区间集合中。</li>\n\t<li><strong>统计：</strong>计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p>实现 <code>CountIntervals</code> 类：</p>\n\n<ul>\n\t<li><code>CountIntervals()</code> 使用区间的空集初始化对象</li>\n\t<li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li>\n\t<li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p><strong>注意：</strong>区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\n[[], [2, 3], [7, 10], [], [5, 8], []]\n<strong>输出</strong>\n[null, null, null, 6, null, 8]\n\n<strong>解释</strong>\nCountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象\ncountIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中\ncountIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中\ncountIntervals.count();    // 返回 6\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 7、8、9、10 出现在区间 [7, 10] 中\ncountIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中\ncountIntervals.count();    // 返回 8\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 5 和 6 出现在区间 [5, 8] 中\n                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中\n                           // 整数 9 和 10 出现在区间 [7, 10] 中</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n\t<li>最多调用&nbsp; <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>调用 <code>count</code> 方法至少一次</li>\n</ul>\n","translatedTitle":"统计区间中的整数数目","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class CountIntervals {\npublic:\n    CountIntervals() {\n\n    }\n    \n    void add(int left, int right) {\n\n    }\n    \n    int count() {\n\n    }\n};\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals* obj = new CountIntervals();\n * obj->add(left,right);\n * int param_2 = obj->count();\n */"},{"lang":"Java","langSlug":"java","code":"class CountIntervals {\n\n    public CountIntervals() {\n\n    }\n    \n    public void add(int left, int right) {\n\n    }\n    \n    public int count() {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals obj = new CountIntervals();\n * obj.add(left,right);\n * int param_2 = obj.count();\n */"},{"lang":"Python","langSlug":"python","code":"class CountIntervals(object):\n\n    def __init__(self):\n\n\n    def add(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: None\n        \"\"\"\n\n\n    def count(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left,right)\n# param_2 = obj.count()"},{"lang":"Python3","langSlug":"python3","code":"class CountIntervals:\n\n    def __init__(self):\n\n\n    def add(self, left: int, right: int) -> None:\n\n\n    def count(self) -> int:\n\n\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals()\n# obj.add(left,right)\n# param_2 = obj.count()"},{"lang":"C","langSlug":"c","code":"\n\n\ntypedef struct {\n\n} CountIntervals;\n\n\nCountIntervals* countIntervalsCreate() {\n\n}\n\nvoid countIntervalsAdd(CountIntervals* obj, int left, int right) {\n\n}\n\nint countIntervalsCount(CountIntervals* obj) {\n\n}\n\nvoid countIntervalsFree(CountIntervals* obj) {\n\n}\n\n/**\n * Your CountIntervals struct will be instantiated and called as such:\n * CountIntervals* obj = countIntervalsCreate();\n * countIntervalsAdd(obj, left, right);\n \n * int param_2 = countIntervalsCount(obj);\n \n * countIntervalsFree(obj);\n*/"},{"lang":"C#","langSlug":"csharp","code":"public class CountIntervals {\n\n    public CountIntervals() {\n\n    }\n    \n    public void Add(int left, int right) {\n\n    }\n    \n    public int Count() {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * CountIntervals obj = new CountIntervals();\n * obj.Add(left,right);\n * int param_2 = obj.Count();\n */"},{"lang":"JavaScript","langSlug":"javascript","code":"\nvar CountIntervals = function() {\n\n};\n\n/** \n * @param {number} left \n * @param {number} right\n * @return {void}\n */\nCountIntervals.prototype.add = function(left, right) {\n\n};\n\n/**\n * @return {number}\n */\nCountIntervals.prototype.count = function() {\n\n};\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * var obj = new CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"},{"lang":"Ruby","langSlug":"ruby","code":"class CountIntervals\n    def initialize()\n\n    end\n\n\n=begin\n    :type left: Integer\n    :type right: Integer\n    :rtype: Void\n=end\n    def add(left, right)\n\n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def count()\n\n    end\n\n\nend\n\n# Your CountIntervals object will be instantiated and called as such:\n# obj = CountIntervals.new()\n# obj.add(left, right)\n# param_2 = obj.count()"},{"lang":"Swift","langSlug":"swift","code":"\nclass CountIntervals {\n\n    init() {\n\n    }\n    \n    func add(_ left: Int, _ right: Int) {\n\n    }\n    \n    func count() -> Int {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * let obj = CountIntervals()\n * obj.add(left, right)\n * let ret_2: Int = obj.count()\n */"},{"lang":"Go","langSlug":"golang","code":"type CountIntervals struct {\n\n}\n\n\nfunc Constructor() CountIntervals {\n\n}\n\n\nfunc (this *CountIntervals) Add(left int, right int)  {\n\n}\n\n\nfunc (this *CountIntervals) Count() int {\n\n}\n\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(left,right);\n * param_2 := obj.Count();\n */"},{"lang":"Scala","langSlug":"scala","code":"class CountIntervals() {\n\n    def add(left: Int, right: Int) {\n\n    }\n\n    def count(): Int = {\n\n    }\n\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * var obj = new CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"},{"lang":"Kotlin","langSlug":"kotlin","code":"class CountIntervals() {\n\n    fun add(left: Int, right: Int) {\n\n    }\n\n    fun count(): Int {\n\n    }\n\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * var obj = CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"},{"lang":"Rust","langSlug":"rust","code":"struct CountIntervals {\n\n}\n\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl CountIntervals {\n\n    fn new() -> Self {\n\n    }\n    \n    fn add(&self, left: i32, right: i32) {\n\n    }\n    \n    fn count(&self) -> i32 {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * let obj = CountIntervals::new();\n * obj.add(left, right);\n * let ret_2: i32 = obj.count();\n */"},{"lang":"PHP","langSlug":"php","code":"class CountIntervals {\n    /**\n     */\n    function __construct() {\n\n    }\n\n    /**\n     * @param Integer $left\n     * @param Integer $right\n     * @return NULL\n     */\n    function add($left, $right) {\n\n    }\n\n    /**\n     * @return Integer\n     */\n    function count() {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * $obj = CountIntervals();\n * $obj->add($left, $right);\n * $ret_2 = $obj->count();\n */"},{"lang":"TypeScript","langSlug":"typescript","code":"class CountIntervals {\n    constructor() {\n\n    }\n\n    add(left: number, right: number): void {\n\n    }\n\n    count(): number {\n\n    }\n}\n\n/**\n * Your CountIntervals object will be instantiated and called as such:\n * var obj = new CountIntervals()\n * obj.add(left,right)\n * var param_2 = obj.count()\n */"},{"lang":"Racket","langSlug":"racket","code":"(define count-intervals%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? exact-integer? -> void?\n    (define/public (add left right)\n\n      )\n    ; count : -> exact-integer?\n    (define/public (count)\n\n      )))\n\n;; Your count-intervals% object will be instantiated and called as such:\n;; (define obj (new count-intervals%))\n;; (send obj add left right)\n;; (define param_2 (send obj count))"},{"lang":"Erlang","langSlug":"erlang","code":"-spec count_intervals_init_() -> any().\ncount_intervals_init_() ->\n  .\n\n-spec count_intervals_add(Left :: integer(), Right :: integer()) -> any().\ncount_intervals_add(Left, Right) ->\n  .\n\n-spec count_intervals_count() -> integer().\ncount_intervals_count() ->\n  .\n\n\n%% Your functions will be called as such:\n%% count_intervals_init_(),\n%% count_intervals_add(Left, Right),\n%% Param_2 = count_intervals_count(),\n\n%% count_intervals_init_ will be called before every test case, in which you can do some necessary initializations."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule CountIntervals do\n  @spec init_() :: any\n  def init_() do\n\n  end\n\n  @spec add(left :: integer, right :: integer) :: any\n  def add(left, right) do\n\n  end\n\n  @spec count() :: integer\n  def count() do\n\n  end\nend\n\n# Your functions will be called as such:\n# CountIntervals.init_()\n# CountIntervals.add(left, right)\n# param_2 = CountIntervals.count()\n\n# CountIntervals.init_ will be called before every test case, in which you can do some necessary initializations."}]}