{"slug":"amount-of-time-for-binary-tree-to-be-infected","id":2461,"frontendId":6154,"title":"Amount of Time for Binary Tree to Be Infected","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":3,"dislikes":0,"status":2,"tag":[],"totalAccepted":3248,"totalSubmission":8225,"hints":["Convert the tree to an undirected graph to make it easier to handle.","Use BFS starting at the start node to find the distance between each node and the start node. The answer is the maximum distance."],"sampleTestCase":"[1,5,3,null,4,10,6,9,2]\n3","exampleTestcases":"[1,5,3,null,4,10,6,9,2]\n3\n[1]\n1","content":"<p>You are given the <code>root</code> of a binary tree with <strong>unique</strong> values, and an integer <code>start</code>. At minute <code>0</code>, an <strong>infection</strong> starts from the node with value <code>start</code>.</p>\n\n<p>Each minute, a node becomes infected if:</p>\n\n<ul>\n\t<li>The node is currently uninfected.</li>\n\t<li>The node is adjacent to an infected node.</li>\n</ul>\n\n<p>Return <em>the number of minutes needed for the entire tree to be infected.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-06-25-image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\" />\n<pre>\n<strong>Input:</strong> root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-06-25-image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\" />\n<pre>\n<strong>Input:</strong> root = [1], start = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> At minute 0, the only node in the tree is infected so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>Each node has a <strong>unique</strong> value.</li>\n\t<li>A node with a value of <code>start</code> exists in the tree.</li>\n</ul>\n","translatedContent":"<p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>\n\n<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>\n\n<ul>\n\t<li>节点此前还没有感染。</li>\n\t<li>节点与一个已感染节点相邻。</li>\n</ul>\n\n<p>返回感染整棵树需要的分钟数<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-06-25-image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\">\n<pre><strong>输入：</strong>root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>节点按以下过程被感染：\n- 第 0 分钟：节点 3\n- 第 1 分钟：节点 1、10、6\n- 第 2 分钟：节点5\n- 第 3 分钟：节点 4\n- 第 4 分钟：节点 9 和 2\n感染整棵树需要 4 分钟，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-06-25-image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\">\n<pre><strong>输入：</strong>root = [1], start = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>每个节点的值 <strong>互不相同</strong></li>\n\t<li>树中必定存在值为 <code>start</code> 的节点</li>\n</ul>\n","translatedTitle":"感染二叉树需要的总时间","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int amountOfTime(TreeNode* root, int start) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int amountOfTime(TreeNode root, int start) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def amountOfTime(self, root, start):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type start: int\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:"},{"lang":"C","langSlug":"c","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint amountOfTime(struct TreeNode* root, int start){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int AmountOfTime(TreeNode root, int start) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} start\n * @return {number}\n */\nvar amountOfTime = function(root, start) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} start\n# @return {Integer}\ndef amount_of_time(root, start)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func amountOfTime(_ root: TreeNode?, _ start: Int) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc amountOfTime(root *TreeNode, start int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def amountOfTime(root: TreeNode, start: Int): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun amountOfTime(root: TreeNode?, start: Int): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn amount_of_time(root: Option<Rc<RefCell<TreeNode>>>, start: i32) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $start\n     * @return Integer\n     */\n    function amountOfTime($root, $start) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction amountOfTime(root: TreeNode | null, start: number): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (amount-of-time root start)\n  (-> (or/c tree-node? #f) exact-integer? exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec amount_of_time(Root :: #tree_node{} | null, Start :: integer()) -> integer().\namount_of_time(Root, Start) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec amount_of_time(root :: TreeNode.t | nil, start :: integer) :: integer\n  def amount_of_time(root, start) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int amountOfTime(TreeNode? root, int start) {\n\n  }\n}"}]}