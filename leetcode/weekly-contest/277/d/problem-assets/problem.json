{"slug":"maximum-good-people-based-on-statements","id":2272,"title":"Maximum Good People Based on Statements","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":28,"dislikes":0,"status":0,"tag":[{"name":"Bit Manipulation","slug":"bit-manipulation","translatedName":"位运算"},{"name":"Array","slug":"array","translatedName":"数组"},{"name":"Backtracking","slug":"backtracking","translatedName":"回溯"},{"name":"Enumeration","slug":"enumeration","translatedName":"枚举"}],"totalAccepted":3890,"totalSubmission":8235,"hints":["You should test every possible assignment of good and bad people, using a bitmask.","In each bitmask, if the person i is good, then his statements should be consistent with the bitmask in order for the assignment to be valid.","If the assignment is valid, count how many people are good and keep track of the maximum."],"sampleTestCase":"[[2,1,2],[1,2,2],[2,0,2]]","exampleTestcases":"[[2,1,2],[1,2,2],[2,0,2]]\n[[2,0],[0,2]]","content":"<p>There are two types of persons:</p>\n\n<ul>\n\t<li>The <strong>good person</strong>: The person who always tells the truth.</li>\n\t<li>The <strong>bad person</strong>: The person who might tell the truth and might lie.</li>\n</ul>\n\n<p>You are given a <strong>0-indexed</strong> 2D integer array <code>statements</code> of size <code>n x n</code> that represents the statements made by <code>n</code> people about each other. More specifically, <code>statements[i][j]</code> could be one of the following:</p>\n\n<ul>\n\t<li><code>0</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>bad</strong> person.</li>\n\t<li><code>1</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>good</strong> person.</li>\n\t<li><code>2</code> represents that <strong>no statement</strong> is made by person <code>i</code> about person <code>j</code>.</li>\n</ul>\n\n<p>Additionally, no person ever makes a statement about themselves. Formally, we have that <code>statements[i][i] = 2</code> for all <code>0 &lt;= i &lt; n</code>.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of people who can be <strong>good</strong> based on the statements made by the </em><code>n</code><em> people</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-01-15-logic1.jpg\" style=\"width: 600px; height: 262px;\" />\n<pre>\n<strong>Input:</strong> statements = [[2,1,2],[1,2,2],[2,0,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet&#39;s take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - <strong>Following that person 2 is a good person, there will be only one good person in the group</strong>.\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - <strong>Following that person 2 is bad but told the truth, there will be no good persons in the group</strong>.\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - <strong>Following that person 2 is bad and lied, there will be two good persons in the group</strong>.\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-01-15-logic2.jpg\" style=\"width: 600px; height: 262px;\" />\n<pre>\n<strong>Input:</strong> statements = [[2,0],[0,2]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet&#39;s take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - <strong>Following that person 0 is a good person, there will be only one good person in the group</strong>.\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - <strong>Following that person 0 is bad but told the truth, there will be no good persons in the group</strong>.\n        - lying. In this case person 1 is a good person.\n            - <strong>Following that person 0 is bad and lied, there will be only one good person in the group</strong>.\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == statements.length == statements[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>statements[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n\t<li><code>statements[i][i] == 2</code></li>\n</ul>\n","translatedContent":"<p>游戏中存在两种角色：</p>\n\n<ul>\n\t<li><strong>好人</strong>：该角色只说真话。</li>\n\t<li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li>\n\t<li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li>\n\t<li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li>\n</ul>\n\n<p>另外，玩家不会对自己进行陈述。形式上，对所有&nbsp;<code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p>\n\n<p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-01-15-logic1.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,1,2],[1,2,2],[2,0,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是好人。\n- 1 认为 0 是好人。\n- 2 认为 1 是坏人。\n以 2 为突破点。\n- 假设 2 是一个好人：\n    - 基于 2 的陈述，1 是坏人。\n    - 那么可以确认 1 是坏人，2 是好人。\n    - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下会出现矛盾，所以假设无效。\n        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。\n    - <strong>在认为 2 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 2 是一个坏人：\n    - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - 由于 1 是好人，0 也是好人。\n            - <strong>在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。</strong>\n在最佳情况下，至多有两个好人，所以返回 2 。\n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-01-15-logic2.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,0],[0,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是坏人。\n- 1 认为 0 是坏人。\n以 0 为突破点。\n- 假设 0 是一个好人：\n    - 基于与 0 的陈述，1 是坏人并说假话。\n    - <strong>在认为 0 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 0 是一个坏人：\n    - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - <strong>在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。</strong>\n在最佳情况下，至多有一个好人，所以返回 1 。 \n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == statements.length == statements[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li>\n\t<li><code>statements[i][i] == 2</code></li>\n</ul>\n","translatedTitle":"基于陈述统计最多好人数","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int maximumGood(vector<vector<int>>& statements) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int maximumGood(int[][] statements) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def maximumGood(self, statements):\n        \"\"\"\n        :type statements: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def maximumGood(self, statements: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint maximumGood(int** statements, int statementsSize, int* statementsColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MaximumGood(int[][] statements) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[][]} statements\n * @return {number}\n */\nvar maximumGood = function(statements) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[][]} statements\n# @return {Integer}\ndef maximum_good(statements)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func maximumGood(_ statements: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func maximumGood(statements [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def maximumGood(statements: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun maximumGood(statements: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn maximum_good(statements: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[][] $statements\n     * @return Integer\n     */\n    function maximumGood($statements) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function maximumGood(statements: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (maximum-good statements)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec maximum_good(Statements :: [[integer()]]) -> integer().\nmaximum_good(Statements) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec maximum_good(statements :: [[integer]]) :: integer\n  def maximum_good(statements) do\n\n  end\nend"}]}