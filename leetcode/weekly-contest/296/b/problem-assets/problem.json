{"slug":"partition-array-such-that-maximum-difference-is-k","id":2387,"frontendId":6091,"title":"Partition Array Such That Maximum Difference Is K","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":0,"dislikes":0,"status":2,"tag":[],"totalAccepted":3910,"totalSubmission":5923,"hints":["Which values in each subsequence matter? The only values that matter are the maximum and minimum values.","Let the maximum and minimum values of a subsequence be Max and Min. It is optimal to place all values in between Max and Min in the original array in the same subsequence as Max and Min.","Sort the array."],"sampleTestCase":"[3,6,1,2,5]\n2","exampleTestcases":"[3,6,1,2,5]\n2\n[1,2,3]\n1\n[2,2,4,5]\n0","content":"<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. You may partition <code>nums</code> into one or more <strong>subsequences</strong> such that each element in <code>nums</code> appears in <strong>exactly</strong> one of the subsequences.</p>\n\n<p>Return <em>the <strong>minimum </strong>number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is <strong>at most</strong> </em><code>k</code><em>.</em></p>\n\n<p>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,1,2,5], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can partition nums into the two subsequences [3,1,2] and [6,5].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], k = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can partition nums into the two subsequences [1,2] and [3].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,4,5], k = 0\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nWe can partition nums into the three subsequences [2,2], [4], and [5].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n","translatedContent":"<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p>\n\n<p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p>\n\n<p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,1,2,5], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。\n第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。\n第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。\n由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以将 nums 划分为两个子序列 [1,2] 和 [3] 。\n第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。\n第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。\n由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,4,5], k = 0\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。\n第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。\n第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。\n第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。\n由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n","translatedTitle":"划分数组使最大差为 K","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int partitionArray(vector<int>& nums, int k) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int partitionArray(int[] nums, int k) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def partitionArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def partitionArray(self, nums: List[int], k: int) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint partitionArray(int* nums, int numsSize, int k){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int PartitionArray(int[] nums, int k) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar partitionArray = function(nums, k) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Integer}\ndef partition_array(nums, k)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func partitionArray(_ nums: [Int], _ k: Int) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func partitionArray(nums []int, k int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def partitionArray(nums: Array[Int], k: Int): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun partitionArray(nums: IntArray, k: Int): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn partition_array(nums: Vec<i32>, k: i32) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer\n     */\n    function partitionArray($nums, $k) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function partitionArray(nums: number[], k: number): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (partition-array nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec partition_array(Nums :: [integer()], K :: integer()) -> integer().\npartition_array(Nums, K) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec partition_array(nums :: [integer], k :: integer) :: integer\n  def partition_array(nums, k) do\n\n  end\nend"}]}