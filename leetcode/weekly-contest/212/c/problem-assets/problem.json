{"slug":"path-with-minimum-effort","id":1753,"title":"Path With Minimum Effort","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":268,"dislikes":0,"status":2,"tag":[{"name":"Depth-First Search","slug":"depth-first-search","translatedName":"深度优先搜索"},{"name":"Breadth-First Search","slug":"breadth-first-search","translatedName":"广度优先搜索"},{"name":"Union Find","slug":"union-find","translatedName":"并查集"},{"name":"Array","slug":"array","translatedName":"数组"},{"name":"Binary Search","slug":"binary-search","translatedName":"二分查找"},{"name":"Matrix","slug":"matrix","translatedName":"矩阵"},{"name":"Heap (Priority Queue)","slug":"heap-priority-queue","translatedName":"堆（优先队列）"}],"totalAccepted":28321,"totalSubmission":57139,"hints":["Consider the grid as a graph, where adjacent cells have an edge with cost of the difference between the cells.","If you are given threshold k, check if it is possible to go from (0, 0) to (n-1, m-1) using only edges of ≤ k cost.","Binary search the k value."],"sampleTestCase":"[[1,2,2],[3,8,2],[5,3,5]]","exampleTestcases":"[[1,2,2],[3,8,2],[5,3,5]]\n[[1,2,3],[3,8,4],[5,3,5]]\n[[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]","content":"<p>You are a hiker preparing for an upcoming hike. You are given <code>heights</code>, a 2D array of size <code>rows x columns</code>, where <code>heights[row][col]</code> represents the height of cell <code>(row, col)</code>. You are situated in the top-left cell, <code>(0, 0)</code>, and you hope to travel to the bottom-right cell, <code>(rows-1, columns-1)</code> (i.e.,&nbsp;<strong>0-indexed</strong>). You can move <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>, and you wish to find a route that requires the minimum <strong>effort</strong>.</p>\r\n\r\n<p>A route&#39;s <strong>effort</strong> is the <strong>maximum absolute difference</strong><strong> </strong>in heights between two consecutive cells of the route.</p>\r\n\r\n<p>Return <em>the minimum <strong>effort</strong> required to travel from the top-left cell to the bottom-right cell.</em></p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-10-04-ex1.png\" style=\"width: 300px; height: 300px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> heights = [[1,2,2],[3,8,2],[5,3,5]]\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.\r\nThis is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-10-04-ex2.png\" style=\"width: 300px; height: 300px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> heights = [[1,2,3],[3,8,4],[5,3,5]]\r\n<strong>Output:</strong> 1\r\n<strong>Explanation:</strong> The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-10-04-ex3.png\" style=\"width: 300px; height: 300px;\" />\r\n<pre>\r\n<strong>Input:</strong> heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> This route does not require any effort.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>rows == heights.length</code></li>\r\n\t<li><code>columns == heights[i].length</code></li>\r\n\t<li><code>1 &lt;= rows, columns &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= heights[i][j] &lt;= 10<sup>6</sup></code></li>\r\n</ul>","translatedContent":"<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>\n\n<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>\n\n<p>请你返回从左上角走到右下角的最小<strong> 体力消耗值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-10-25-ex1.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,2],[3,8,2],[5,3,5]]\n<b>输出：</b>2\n<b>解释：</b>路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。\n这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-10-25-ex2.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,3],[3,8,4],[5,3,5]]\n<b>输出：</b>1\n<b>解释：</b>路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-10-25-ex3.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n<b>输出：</b>0\n<b>解释：</b>上图所示路径不需要消耗任何体力。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == heights.length</code></li>\n\t<li><code>columns == heights[i].length</code></li>\n\t<li><code>1 <= rows, columns <= 100</code></li>\n\t<li><code>1 <= heights[i][j] <= 10<sup>6</sup></code></li>\n</ul>\n","translatedTitle":"最小体力消耗路径","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int minimumEffortPath(vector<vector<int>>& heights) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int minimumEffortPath(int[][] heights) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def minimumEffortPath(self, heights):\n        \"\"\"\n        :type heights: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"int minimumEffortPath(int** heights, int heightsSize, int* heightsColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MinimumEffortPath(int[][] heights) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[][]} heights\n * @return {number}\n */\nvar minimumEffortPath = function(heights) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[][]} heights\n# @return {Integer}\ndef minimum_effort_path(heights)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func minimumEffortPath(_ heights: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func minimumEffortPath(heights [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def minimumEffortPath(heights: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun minimumEffortPath(heights: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn minimum_effort_path(heights: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[][] $heights\n     * @return Integer\n     */\n    function minimumEffortPath($heights) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function minimumEffortPath(heights: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (minimum-effort-path heights)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec minimum_effort_path(Heights :: [[integer()]]) -> integer().\nminimum_effort_path(Heights) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec minimum_effort_path(heights :: [[integer]]) :: integer\n  def minimum_effort_path(heights) do\n\n  end\nend"}]}