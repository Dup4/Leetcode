{"slug":"split-two-strings-to-make-palindrome","id":1739,"title":"Split Two Strings to Make Palindrome","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":41,"dislikes":0,"status":2,"tag":[{"name":"Greedy","slug":"greedy","translatedName":"贪心"},{"name":"Two Pointers","slug":"two-pointers","translatedName":"双指针"},{"name":"String","slug":"string","translatedName":"字符串"}],"totalAccepted":5424,"totalSubmission":19464,"hints":["Try finding the largest prefix form a that matches a suffix in b","Try string matching"],"sampleTestCase":"\"x\"\n\"y\"","exampleTestcases":"\"x\"\n\"y\"\n\"xbdef\"\n\"xecab\"\n\"ulacfd\"\n\"jizalu\"","content":"<p>You are given two strings <code>a</code> and <code>b</code> of the same length. Choose an index and split both strings <strong>at the same index</strong>, splitting <code>a</code> into two strings: <code>a<sub>prefix</sub></code> and <code>a<sub>suffix</sub></code> where <code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code>, and splitting <code>b</code> into two strings: <code>b<sub>prefix</sub></code> and <code>b<sub>suffix</sub></code> where <code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>. Check if <code>a<sub>prefix</sub> + b<sub>suffix</sub></code> or <code>b<sub>prefix</sub> + a<sub>suffix</sub></code> forms a palindrome.</p>\n\n<p>When you split a string <code>s</code> into <code>s<sub>prefix</sub></code> and <code>s<sub>suffix</sub></code>, either <code>s<sub>suffix</sub></code> or <code>s<sub>prefix</sub></code> is allowed to be empty. For example, if <code>s = &quot;abc&quot;</code>, then <code>&quot;&quot; + &quot;abc&quot;</code>, <code>&quot;a&quot; + &quot;bc&quot;</code>, <code>&quot;ab&quot; + &quot;c&quot;</code> , and <code>&quot;abc&quot; + &quot;&quot;</code> are valid splits.</p>\n\n<p>Return <code>true</code><em> if it is possible to form</em><em> a palindrome string, otherwise return </em><code>false</code>.</p>\n\n<p><strong>Notice</strong> that&nbsp;<code>x + y</code> denotes the concatenation of strings <code>x</code> and <code>y</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;x&quot;, b = &quot;y&quot;\n<strong>Output:</strong> true\n<strong>Explaination:</strong> If either a or b are palindromes the answer is true since you can split in the following way:\na<sub>prefix</sub> = &quot;&quot;, a<sub>suffix</sub> = &quot;x&quot;\nb<sub>prefix</sub> = &quot;&quot;, b<sub>suffix</sub> = &quot;y&quot;\nThen, a<sub>prefix</sub> + b<sub>suffix</sub> = &quot;&quot; + &quot;y&quot; = &quot;y&quot;, which is a palindrome.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;xbdef&quot;, b = &quot;xecab&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;\n<strong>Output:</strong> true\n<strong>Explaination:</strong> Split them at index 3:\na<sub>prefix</sub> = &quot;ula&quot;, a<sub>suffix</sub> = &quot;cfd&quot;\nb<sub>prefix</sub> = &quot;jiz&quot;, b<sub>suffix</sub> = &quot;alu&quot;\nThen, a<sub>prefix</sub> + b<sub>suffix</sub> = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot;, which is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a.length == b.length</code></li>\n\t<li><code>a</code> and <code>b</code> consist of lowercase English letters</li>\n</ul>\n","translatedContent":"<p>给你两个字符串 <code>a</code> 和 <code>b</code> ，它们长度相同。请你选择一个下标，将两个字符串都在 <strong>相同的下标 </strong>分割开。由 <code>a</code> 可以得到两个字符串： <code>a<sub>prefix</sub></code> 和 <code>a<sub>suffix</sub></code> ，满足 <code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub> </sub>，同理，由 <code>b</code> 可以得到两个字符串 <code>b<sub>prefix</sub></code> 和 <code>b<sub>suffix</sub></code> ，满足 <code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code> 。请你判断 <code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者 <code>b<sub>prefix</sub> + a<sub>suffix</sub></code> 能否构成回文串。</p>\n\n<p>当你将一个字符串 <code>s</code> 分割成 <code>s<sub>prefix</sub></code> 和 <code>s<sub>suffix</sub></code> 时， <code>s<sub>suffix</sub></code> 或者 <code>s<sub>prefix</sub></code> 可以为空。比方说， <code>s = \"abc\"</code> 那么 <code>\"\" + \"abc\"</code> ， <code>\"a\" + \"bc\" </code>， <code>\"ab\" + \"c\"</code> 和 <code>\"abc\" + \"\"</code> 都是合法分割。</p>\n\n<p>如果 <strong>能构成回文字符串</strong> ，那么请返回 <code>true</code>，否则返回<em> </em><code>false</code> 。</p>\n\n<p><strong>注意</strong>， <code>x + y</code> 表示连接字符串 <code>x</code> 和 <code>y</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"x\", b = \"y\"\n<b>输出：</b>true\n<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\na<sub>prefix</sub> = \"\", a<sub>suffix</sub> = \"x\"\nb<sub>prefix</sub> = \"\", b<sub>suffix</sub> = \"y\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"\" + \"y\" = \"y\" 是回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"abdef\", b = \"fecab\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"ulacfd\", b = \"jizalu\"\n<b>输出：</b>true\n<b>解释：</b>在下标为 3 处分割：\na<sub>prefix</sub> = \"ula\", a<sub>suffix</sub> = \"cfd\"\nb<sub>prefix</sub> = \"jiz\", b<sub>suffix</sub> = \"alu\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"ula\" + \"alu\" = \"ulaalu\" 是回文串。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"xbdef\", b = \"xecab\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a.length, b.length <= 10<sup>5</sup></code></li>\n\t<li><code>a.length == b.length</code></li>\n\t<li><code>a</code> 和 <code>b</code> 都只包含小写英文字母</li>\n</ul>\n","translatedTitle":"分割两个字符串得到回文串","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    bool checkPalindromeFormation(string a, string b) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public boolean checkPalindromeFormation(String a, String b) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def checkPalindromeFormation(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: bool\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def checkPalindromeFormation(self, a: str, b: str) -> bool:"},{"lang":"C","langSlug":"c","code":"\n\nbool checkPalindromeFormation(char * a, char * b){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public bool CheckPalindromeFormation(string a, string b) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nvar checkPalindromeFormation = function(a, b) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {String} a\n# @param {String} b\n# @return {Boolean}\ndef check_palindrome_formation(a, b)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func checkPalindromeFormation(_ a: String, _ b: String) -> Bool {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func checkPalindromeFormation(a string, b string) bool {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def checkPalindromeFormation(a: String, b: String): Boolean = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun checkPalindromeFormation(a: String, b: String): Boolean {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn check_palindrome_formation(a: String, b: String) -> bool {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param String $a\n     * @param String $b\n     * @return Boolean\n     */\n    function checkPalindromeFormation($a, $b) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function checkPalindromeFormation(a: string, b: string): boolean {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (check-palindrome-formation a b)\n  (-> string? string? boolean?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec check_palindrome_formation(A :: unicode:unicode_binary(), B :: unicode:unicode_binary()) -> boolean().\ncheck_palindrome_formation(A, B) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec check_palindrome_formation(a :: String.t, b :: String.t) :: boolean\n  def check_palindrome_formation(a, b) do\n\n  end\nend"}]}