{"slug":"maximum-nesting-depth-of-the-parentheses","id":1737,"title":"Maximum Nesting Depth of the Parentheses","categoryTitle":"Algorithms","difficulty":0,"starred":false,"locked":false,"likes":95,"dislikes":0,"status":2,"tag":[{"name":"Stack","slug":"stack","translatedName":"栈"},{"name":"String","slug":"string","translatedName":"字符串"}],"totalAccepted":46223,"totalSubmission":54267,"hints":["The depth of any character in the VPS is the ( number of left brackets before it ) - ( number of right brackets before it )"],"sampleTestCase":"\"(1+(2*3)+((8)/4))+1\"","exampleTestcases":"\"(1+(2*3)+((8)/4))+1\"\n\"(1)+((2))+(((3)))\"","content":"<p>A string is a <strong>valid parentheses string</strong> (denoted <strong>VPS</strong>) if it meets one of the following:</p>\n\n<ul>\n\t<li>It is an empty string <code>&quot;&quot;</code>, or a single character not equal to <code>&quot;(&quot;</code> or <code>&quot;)&quot;</code>,</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are <strong>VPS</strong>&#39;s, or</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a <strong>VPS</strong>.</li>\n</ul>\n\n<p>We can similarly define the <strong>nesting depth</strong> <code>depth(S)</code> of any VPS <code>S</code> as follows:</p>\n\n<ul>\n\t<li><code>depth(&quot;&quot;) = 0</code></li>\n\t<li><code>depth(C) = 0</code>, where <code>C</code> is a string with a single character not equal to <code>&quot;(&quot;</code> or <code>&quot;)&quot;</code>.</li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>, where <code>A</code> and <code>B</code> are <strong>VPS</strong>&#39;s.</li>\n\t<li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>, where <code>A</code> is a <strong>VPS</strong>.</li>\n</ul>\n\n<p>For example, <code>&quot;&quot;</code>, <code>&quot;()()&quot;</code>, and <code>&quot;()(()())&quot;</code> are <strong>VPS</strong>&#39;s (with nesting depths 0, 1, and 2), and <code>&quot;)(&quot;</code> and <code>&quot;(()&quot;</code> are not <strong>VPS</strong>&#39;s.</p>\n\n<p>Given a <strong>VPS</strong> represented as string <code>s</code>, return <em>the <strong>nesting depth</strong> of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(2*3)+((<u>8</u>)/4))+1&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Digit 8 is inside of 3 nested parentheses in the string.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1)+((2))+(((<u>3</u>)))&quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of digits <code>0-9</code> and characters <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;(&#39;</code>, and <code>&#39;)&#39;</code>.</li>\n\t<li>It is guaranteed that parentheses expression <code>s</code> is a <strong>VPS</strong>.</li>\n</ul>\n","translatedContent":"<p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串</strong><strong>（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p>\n\n<ul>\n\t<li>字符串是一个空字符串 <code>\"\"</code>，或者是一个不为 <code>\"(\"</code> 或 <code>\")\"</code> 的单字符。</li>\n\t<li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code> 字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li>\n\t<li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li>\n</ul>\n\n<p>类似地，可以定义任何有效括号字符串 <code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p>\n\n<ul>\n\t<li><code>depth(\"\") = 0</code></li>\n\t<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>\"(\"</code> 或者 <code>\")\"</code></li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li>\n\t<li><code>depth(\"(\" + A + \")\") = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>\n</ul>\n\n<p>例如：<code>\"\"</code>、<code>\"()()\"</code>、<code>\"()(()())\"</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>\")(\"</code> 、<code>\"(()\"</code> 都不是 <strong>有效括号字符串</strong> 。</p>\n\n<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的<em> </em><code>s</code> <strong>嵌套深度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(2*3)+((<strong>8</strong>)/4))+1\"\n<strong>输出：</strong>3\n<strong>解释：</strong>数字 8 在嵌套的 3 层括号中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1)+((2))+(((<strong>3</strong>)))\"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1+(<strong>2</strong>*3)/(2-1)\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"<strong>1</strong>\"\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>'+'</code>、<code>'-'</code>、<code>'*'</code>、<code>'/'</code>、<code>'('</code>、<code>')'</code> 组成</li>\n\t<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>\n</ul>\n","translatedTitle":"括号的最大嵌套深度","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int maxDepth(string s) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int maxDepth(String s) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def maxDepth(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def maxDepth(self, s: str) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint maxDepth(char * s){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MaxDepth(string s) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {string} s\n * @return {number}\n */\nvar maxDepth = function(s) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {String} s\n# @return {Integer}\ndef max_depth(s)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func maxDepth(_ s: String) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func maxDepth(s string) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def maxDepth(s: String): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun maxDepth(s: String): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn max_depth(s: String) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function maxDepth($s) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function maxDepth(s: string): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (max-depth s)\n  (-> string? exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec max_depth(S :: unicode:unicode_binary()) -> integer().\nmax_depth(S) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec max_depth(s :: String.t) :: integer\n  def max_depth(s) do\n\n  end\nend"}]}