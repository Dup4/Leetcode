{"slug":"minimum-total-distance-traveled","id":2554,"frontendId":6232,"title":"Minimum Total Distance Traveled","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":1,"dislikes":0,"status":2,"tag":[],"totalAccepted":405,"totalSubmission":1731,"hints":["Sort robots and factories by their positions.","After sorting, notice that each factory should repair some subsegment of robots.","Find the minimum total distance to repair first i robots with first j factories."],"sampleTestCase":"[0,4,6]\n[[2,2],[6,2]]","exampleTestcases":"[0,4,6]\n[[2,2],[6,2]]\n[1,-1]\n[[-2,1],[2,1]]","content":"<p>There are some robots and factories on the X-axis. You are given an integer array <code>robot</code> where <code>robot[i]</code> is the position of the <code>i<sup>th</sup></code> robot. You are also given a 2D integer array <code>factory</code> where <code>factory[j] = [position<sub>j</sub>, limit<sub>j</sub>]</code> indicates that <code>position<sub>j</sub></code> is the position of the <code>j<sup>th</sup></code> factory and that the <code>j<sup>th</sup></code> factory can repair at most <code>limit<sub>j</sub></code> robots.</p>\n\n<p>The positions of each robot are <strong>unique</strong>. The positions of each factory are also <strong>unique</strong>. Note that a robot can be <strong>in the same position</strong> as a factory initially.</p>\n\n<p>All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.</p>\n\n<p><strong>At any moment</strong>, you can set the initial direction of moving for <strong>some</strong> robot. Your target is to minimize the total distance traveled by all the robots.</p>\n\n<p>Return <em>the minimum total distance traveled by all the robots</em>. The test cases are generated such that all the robots can be repaired.</p>\n\n<p><strong>Note that</strong></p>\n\n<ul>\n\t<li>All robots move at the same speed.</li>\n\t<li>If two robots move in the same direction, they will never collide.</li>\n\t<li>If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.</li>\n\t<li>If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.</li>\n\t<li>If the robot moved from a position <code>x</code> to a position <code>y</code>, the distance it moved is <code>|y - x|</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-15-example1.jpg\" style=\"width: 500px; height: 320px;\" />\n<pre>\n<strong>Input:</strong> robot = [0,4,6], factory = [[2,2],[6,2]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> As shown in the figure:\n- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.\n- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.\n- The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-15-example-2.jpg\" style=\"width: 500px; height: 329px;\" />\n<pre>\n<strong>Input:</strong> robot = [1,-1], factory = [[-2,1],[2,1]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> As shown in the figure:\n- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.\n- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li>\n\t<li><code>factory[j].length == 2</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= robot[i], position<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= limit<sub>j</sub> &lt;= robot.length</code></li>\n\t<li>The input will be generated such that it is always possible to repair every robot.</li>\n</ul>\n","translatedContent":"<p>X 轴上有一些机器人和工厂。给你一个整数数组&nbsp;<code>robot</code>&nbsp;，其中&nbsp;<code>robot[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个机器人的位置。再给你一个二维整数数组&nbsp;<code>factory</code>&nbsp;，其中&nbsp;<code>factory[j] = [position<sub>j</sub>, limit<sub>j</sub>]</code>&nbsp;，表示第 <code>j</code>&nbsp;个工厂的位置在&nbsp;<code>position<sub>j</sub></code>&nbsp;，且第 <code>j</code>&nbsp;个工厂最多可以修理&nbsp;<code>limit<sub>j</sub></code>&nbsp;个机器人。</p>\n\n<p>每个机器人所在的位置 <strong>互不相同</strong>&nbsp;。每个工厂所在的位置也 <strong>互不相同</strong>&nbsp;。注意一个机器人可能一开始跟一个工厂在 <strong>相同的位置</strong>&nbsp;。</p>\n\n<p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p>\n\n<p><b>任何时刻</b>，你都可以设置&nbsp;<strong>部分</strong>&nbsp;机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p>\n\n<p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>所有机器人移动速度相同。</li>\n\t<li>如果两个机器人移动方向相同，它们永远不会碰撞。</li>\n\t<li>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。</li>\n\t<li>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。</li>\n\t<li>机器人从位置&nbsp;<code>x</code> 到位置&nbsp;<code>y</code>&nbsp;的移动距离为&nbsp;<code>|y - x|</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--pic.leetcode-cn.com-1667542978-utuiPv-image.png\" style=\"width: 500px; height: 320px;\" /></p>\n\n<pre>\n<b>输入：</b>robot = [0,4,6], factory = [[2,2],[6,2]]\n<b>输出：</b>4\n<b>解释：</b>如上图所示：\n- 第一个机器人从位置 0 沿着正方向移动，在第一个工厂处维修。\n- 第二个机器人从位置 4 沿着负方向移动，在第一个工厂处维修。\n- 第三个机器人在位置 6 被第二个工厂维修，它不需要移动。\n第一个工厂的维修上限是 2 ，它维修了 2 个机器人。\n第二个工厂的维修上限是 2 ，它维修了 1 个机器人。\n总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| = 4 。没有办法得到比 4 更少的总移动距离。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--pic.leetcode-cn.com-1667542984-OAIRFN-image.png\" style=\"width: 500px; height: 329px;\" /></p>\n\n<pre>\n<b>输入：</b>robot = [1,-1], factory = [[-2,1],[2,1]]\n<b>输出：</b>2\n<b>解释：</b>如上图所示：\n- 第一个机器人从位置 1 沿着正方向移动，在第二个工厂处维修。\n- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。\n第一个工厂的维修上限是 1 ，它维修了 1 个机器人。\n第二个工厂的维修上限是 1 ，它维修了 1 个机器人。\n总移动距离是 |2 - 1| + |(-2) - (-1)| = 2 。没有办法得到比 2 更少的总移动距离。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li>\n\t<li><code>factory[j].length == 2</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= robot[i], position<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= limit<sub>j</sub> &lt;= robot.length</code></li>\n\t<li>测试数据保证所有机器人都可以被维修。</li>\n</ul>\n","translatedTitle":"最小移动总距离","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public long minimumTotalDistance(List<Integer> robot, int[][] factory) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def minimumTotalDistance(self, robot, factory):\n        \"\"\"\n        :type robot: List[int]\n        :type factory: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"long long minimumTotalDistance(int* robot, int robotSize, int** factory, int factorySize, int* factoryColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public long MinimumTotalDistance(IList<int> robot, int[][] factory) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[]} robot\n * @param {number[][]} factory\n * @return {number}\n */\nvar minimumTotalDistance = function(robot, factory) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[]} robot\n# @param {Integer[][]} factory\n# @return {Integer}\ndef minimum_total_distance(robot, factory)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func minimumTotalDistance(_ robot: [Int], _ factory: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func minimumTotalDistance(robot []int, factory [][]int) int64 {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def minimumTotalDistance(robot: List[Int], factory: Array[Array[Int]]): Long = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun minimumTotalDistance(robot: List<Int>, factory: Array<IntArray>): Long {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn minimum_total_distance(robot: Vec<i32>, factory: Vec<Vec<i32>>) -> i64 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[] $robot\n     * @param Integer[][] $factory\n     * @return Integer\n     */\n    function minimumTotalDistance($robot, $factory) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function minimumTotalDistance(robot: number[], factory: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (minimum-total-distance robot factory)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec minimum_total_distance(Robot :: [integer()], Factory :: [[integer()]]) -> integer().\nminimum_total_distance(Robot, Factory) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec minimum_total_distance(robot :: [integer], factory :: [[integer]]) :: integer\n  def minimum_total_distance(robot, factory) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"class Solution {\n  int minimumTotalDistance(List<int> robot, List<List<int>> factory) {\n\n  }\n}"}]}