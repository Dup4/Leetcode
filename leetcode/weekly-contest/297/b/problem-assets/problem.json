{"slug":"minimum-path-cost-in-a-grid","id":1394,"frontendId":5270,"title":"Minimum Path Cost in a Grid","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":0,"dislikes":0,"status":2,"tag":[{"name":"Dynamic Programming","slug":"dynamic-programming","translatedName":"动态规划"}],"totalAccepted":2778,"totalSubmission":4991,"hints":["What is the optimal cost to get to each of the cells in the second row? What about the third row?","Use dynamic programming to compute the optimal cost to get to each cell."],"sampleTestCase":"[[5,3],[4,0],[2,1]]\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]","exampleTestcases":"[[5,3],[4,0],[2,1]]\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n[[5,1,2],[4,0,3]]\n[[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]","content":"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code> consisting of <strong>distinct</strong> integers from <code>0</code> to <code>m * n - 1</code>. You can move in this matrix from a cell to any other cell in the <strong>next</strong> row. That is, if you are in cell <code>(x, y)</code> such that <code>x &lt; m - 1</code>, you can move to any of the cells <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code>. <strong>Note</strong> that it is not possible to move from cells in the last row.</p>\n\n<p>Each possible move has a cost given by a <strong>0-indexed</strong> 2D array <code>moveCost</code> of size <code>(m * n) x n</code>, where <code>moveCost[i][j]</code> is the cost of moving from a cell with value <code>i</code> to a cell in column <code>j</code> of the next row. The cost of moving from cells in the last row of <code>grid</code> can be ignored.</p>\n\n<p>The cost of a path in <code>grid</code> is the <strong>sum</strong> of all values of cells visited plus the <strong>sum</strong> of costs of all the moves made. Return <em>the <strong>minimum</strong> cost of a path that starts from any cell in the <strong>first</strong> row and ends at any cell in the <strong>last</strong> row.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-04-28-griddrawio-2.png\" style=\"width: 301px; height: 281px;\" />\n<pre>\n<strong>Input:</strong> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n<strong>Output:</strong> 17\n<strong>Explanation: </strong>The path with the minimum possible cost is the path 5 -&gt; 0 -&gt; 1.\n- The sum of the values of cells visited is 5 + 0 + 1 = 6.\n- The cost of moving from 5 to 0 is 3.\n- The cost of moving from 0 to 1 is 8.\nSo the total cost of the path is 6 + 3 + 8 = 17.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The path with the minimum possible cost is the path 2 -&gt; 3.\n- The sum of the values of cells visited is 2 + 3 = 5.\n- The cost of moving from 2 to 3 is 1.\nSo the total cost of this path is 5 + 1 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid</code> consists of distinct integers from <code>0</code> to <code>m * n - 1</code>.</li>\n\t<li><code>moveCost.length == m * n</code></li>\n\t<li><code>moveCost[i].length == n</code></li>\n\t<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>\n</ul>\n","translatedContent":"<p>给你一个下标从 <strong>0</strong> 开始的整数矩阵&nbsp;<code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code><strong> </strong>中的任何一个单元格。<strong>注意：</strong>&nbsp;在最后一行中的单元格不能触发移动。</p>\n\n<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从&nbsp;<code>grid</code> 最后一行的单元格移动的代价可以忽略。</p>\n\n<p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和 </strong>。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-04-28-griddrawio-2.png\" style=\"width: 301px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n<strong>输出：</strong>17\n<strong>解释：</strong>最小代价的路径是 5 -&gt; 0 -&gt; 1 。\n- 路径途经单元格值之和 5 + 0 + 1 = 6 。\n- 从 5 移动到 0 的代价为 3 。\n- 从 0 移动到 1 的代价为 8 。\n路径总代价为 6 + 3 + 8 = 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n最小代价的路径是 2 -&gt; 3 。 \n- 路径途经单元格值之和 2 + 3 = 5 。 \n- 从 2 移动到 3 的代价为 1 。 \n路径总代价为 5 + 1 = 6 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li>\n\t<li><code>moveCost.length == m * n</code></li>\n\t<li><code>moveCost[i].length == n</code></li>\n\t<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>\n</ul>\n","translatedTitle":"网格中的最小路径代价","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int minPathCost(int[][] grid, int[][] moveCost) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def minPathCost(self, grid, moveCost):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type moveCost: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MinPathCost(int[][] grid, int[][] moveCost) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[][]} grid\n * @param {number[][]} moveCost\n * @return {number}\n */\nvar minPathCost = function(grid, moveCost) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[][]} grid\n# @param {Integer[][]} move_cost\n# @return {Integer}\ndef min_path_cost(grid, move_cost)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func minPathCost(_ grid: [[Int]], _ moveCost: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func minPathCost(grid [][]int, moveCost [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def minPathCost(grid: Array[Array[Int]], moveCost: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun minPathCost(grid: Array<IntArray>, moveCost: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn min_path_cost(grid: Vec<Vec<i32>>, move_cost: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer[][] $moveCost\n     * @return Integer\n     */\n    function minPathCost($grid, $moveCost) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function minPathCost(grid: number[][], moveCost: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (min-path-cost grid moveCost)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec min_path_cost(Grid :: [[integer()]], MoveCost :: [[integer()]]) -> integer().\nmin_path_cost(Grid, MoveCost) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec min_path_cost(grid :: [[integer]], move_cost :: [[integer]]) :: integer\n  def min_path_cost(grid, move_cost) do\n\n  end\nend"}]}