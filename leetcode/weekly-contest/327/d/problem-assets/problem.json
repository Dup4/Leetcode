{"slug":"time-to-cross-a-bridge","id":2642,"frontendId":6306,"title":"Time to Cross a Bridge","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":12,"dislikes":0,"status":2,"tag":[],"totalAccepted":643,"totalSubmission":1433,"hints":["Try simulating this process.","We can use a priority queue to query over the least efficient worker."],"sampleTestCase":"1\n3\n[[1,1,2,1],[1,1,3,1],[1,1,4,1]]","exampleTestcases":"1\n3\n[[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n3\n2\n[[1,9,1,8],[10,10,10,10]]","content":"<p>There are <code>k</code> workers who want to move <code>n</code> boxes from an old warehouse to a new one. You are given the two integers <code>n</code> and <code>k</code>, and a 2D integer array <code>time</code> of size <code>k x 4</code> where <code>time[i] = [leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub>]</code>.</p>\n\n<p>The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all <code>k</code> workers are waiting on the left side of the bridge. To move the boxes, the <code>i<sup>th</sup></code> worker (<strong>0-indexed</strong>) can :</p>\n\n<ul>\n\t<li>Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in <code>leftToRight<sub>i</sub></code> minutes.</li>\n\t<li>Pick a box from the old warehouse and return to the bridge in <code>pickOld<sub>i</sub></code> minutes. Different workers can pick up their boxes simultaneously.</li>\n\t<li>Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in <code>rightToLeft<sub>i</sub></code> minutes.</li>\n\t<li>Put the box in the new warehouse and return to the bridge in <code>putNew<sub>i</sub></code> minutes. Different workers can put their boxes simultaneously.</li>\n</ul>\n\n<p>A worker <code>i</code> is <strong>less efficient</strong> than a worker <code>j</code> if either condition is met:</p>\n\n<ul>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> &gt; leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code></li>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> == leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code> and <code>i &gt; j</code></li>\n</ul>\n\n<p>The following rules regulate the movement of the workers through the bridge :</p>\n\n<ul>\n\t<li>If a worker <code>x</code> reaches the bridge while another worker <code>y</code> is crossing the bridge, <code>x</code> waits at their side of the bridge.</li>\n\t<li>If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with <strong>the lowest efficiency</strong> crosses first.</li>\n\t<li>If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with <strong>the lowest efficiency</strong> crosses first.</li>\n</ul>\n\n<p>Return <em>the instance of time at which the last worker <strong>reaches the left bank</strong> of the river after all n boxes have been put in the new warehouse</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n<strong>Output:</strong> 6\n<strong>Explanation: </strong>\nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\n<strong>Output:</strong> 50\n<strong>Explanation:</strong> \nFrom 0 &nbsp;to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>time.length == k</code></li>\n\t<li><code>time[i].length == 4</code></li>\n\t<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n","translatedContent":"<p>共有 <code>k</code> 位工人计划将 <code>n</code> 个箱子从旧仓库移动到新仓库。给你两个整数 <code>n</code> 和 <code>k</code>，以及一个二维整数数组 <code>time</code> ，数组的大小为 <code>k x 4</code> ，其中 <code>time[i] = [leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub>]</code> 。</p>\n\n<p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 <code>k</code> 位工人都在桥的左侧等待。为了移动这些箱子，第 <code>i</code> 位工人（下标从 <strong>0</strong> 开始）可以：</p>\n\n<ul>\n\t<li>从左岸（新仓库）跨过桥到右岸（旧仓库），用时 <code>leftToRight<sub>i</sub></code> 分钟。</li>\n\t<li>从旧仓库选择一个箱子，并返回到桥边，用时 <code>pickOld<sub>i</sub></code> 分钟。不同工人可以同时搬起所选的箱子。</li>\n\t<li>从右岸（旧仓库）跨过桥到左岸（新仓库），用时 <code>rightToLeft<sub>i</sub></code> 分钟。</li>\n\t<li>将箱子放入新仓库，并返回到桥边，用时 <code>putNew<sub>i</sub></code> 分钟。不同工人可以同时放下所选的箱子。</li>\n</ul>\n\n<p>如果满足下面任一条件，则认为工人 <code>i</code> 的 <strong>效率低于</strong> 工人 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> &gt; leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code></li>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> == leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code> 且 <code>i &gt; j</code></li>\n</ul>\n\n<p>工人通过桥时需要遵循以下规则：</p>\n\n<ul>\n\t<li>如果工人 <code>x</code> 到达桥边时，工人 <code>y</code> 正在过桥，那么工人 <code>x</code> 需要在桥边等待。</li>\n\t<li>如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n\t<li>如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n</ul>\n\n<p>所有 <code>n</code> 个盒子都需要放入新仓库，<span class=\"text-only\" data-eleid=\"8\" style=\"white-space: pre;\">请你返回最后一个搬运箱子的工人 </span><strong><span class=\"text-only\" data-eleid=\"9\" style=\"white-space: pre;\">到达河左岸</span></strong><span class=\"text-only\" data-eleid=\"10\" style=\"white-space: pre;\"> 的时间。</span></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n从 0 到 1 ：工人 2 从左岸过桥到达右岸。\n从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。\n从 2 到 6 ：工人 2 从右岸过桥到达左岸。\n从 6 到 7 ：工人 2 将箱子放入新仓库。\n整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\n<strong>输出：</strong>50\n<strong>解释：</strong>\n从 0 到 10 ：工人 1 从左岸过桥到达右岸。\n从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。\n从 10 到 11 ：工人 0 从左岸过桥到达右岸。\n从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。\n从 20 到 30 ：工人 1 从右岸过桥到达左岸。\n从 30 到 40 ：工人 1 将箱子放入新仓库。\n从 30 到 31 ：工人 0 从右岸过桥到达左岸。\n从 31 到 39 ：工人 0 将箱子放入新仓库。\n从 39 到 40 ：工人 0 从左岸过桥到达右岸。\n从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。\n从 49 到 50 ：工人 0 从右岸过桥到达左岸。\n从 50 到 58 ：工人 0 将箱子放入新仓库。\n整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>time.length == k</code></li>\n\t<li><code>time[i].length == 4</code></li>\n\t<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n","translatedTitle":"过桥的时间","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int findCrossingTime(int n, int k, int[][] time) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def findCrossingTime(self, n, k, time):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :type time: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"int findCrossingTime(int n, int k, int** time, int timeSize, int* timeColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int FindCrossingTime(int n, int k, int[][] time) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number} n\n * @param {number} k\n * @param {number[][]} time\n * @return {number}\n */\nvar findCrossingTime = function(n, k, time) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer} n\n# @param {Integer} k\n# @param {Integer[][]} time\n# @return {Integer}\ndef find_crossing_time(n, k, time)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func findCrossingTime(_ n: Int, _ k: Int, _ time: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func findCrossingTime(n int, k int, time [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def findCrossingTime(n: Int, k: Int, time: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun findCrossingTime(n: Int, k: Int, time: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn find_crossing_time(n: i32, k: i32, time: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @param Integer[][] $time\n     * @return Integer\n     */\n    function findCrossingTime($n, $k, $time) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function findCrossingTime(n: number, k: number, time: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (find-crossing-time n k time)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec find_crossing_time(N :: integer(), K :: integer(), Time :: [[integer()]]) -> integer().\nfind_crossing_time(N, K, Time) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec find_crossing_time(n :: integer, k :: integer, time :: [[integer]]) :: integer\n  def find_crossing_time(n, k, time) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"class Solution {\n  int findCrossingTime(int n, int k, List<List<int>> time) {\n\n  }\n}"}]}