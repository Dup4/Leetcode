{"slug":"longest-subarray-with-maximum-bitwise-and","id":2503,"frontendId":6189,"title":"Longest Subarray With Maximum Bitwise AND","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":3,"dislikes":0,"status":2,"tag":[],"totalAccepted":4517,"totalSubmission":12177,"hints":["Notice that the bitwise AND of two different numbers will always be strictly less than the maximum of those two numbers.","What does that tell us about the nature of the subarray that we should choose?"],"sampleTestCase":"[1,2,3,3,2,2]","exampleTestcases":"[1,2,3,3,2,2]\n[1,2,3,4]","content":"<p>You are given an integer array <code>nums</code> of size <code>n</code>.</p>\n\n<p>Consider a <strong>non-empty</strong> subarray from <code>nums</code> that has the <strong>maximum</strong> possible <strong>bitwise AND</strong>.</p>\n\n<ul>\n\t<li>In other words, let <code>k</code> be the maximum value of the bitwise AND of <strong>any</strong> subarray of <code>nums</code>. Then, only subarrays with a bitwise AND equal to <code>k</code> should be considered.</li>\n</ul>\n\n<p>Return <em>the length of the <strong>longest</strong> such subarray</em>.</p>\n\n<p>The bitwise AND of an array is the bitwise AND of all the numbers in it.</p>\n\n<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,2,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe maximum possible bitwise AND of a subarray is 3.\nThe longest subarray with that value is [3,3], so we return 2.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe maximum possible bitwise AND of a subarray is 4.\nThe longest subarray with that value is [4], so we return 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n","translatedContent":"<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p>\n\n<p>考虑 <code>nums</code> 中进行 <strong>按位与（bitwise AND）</strong>运算得到的值 <strong>最大</strong> 的 <strong>非空</strong> 子数组。</p>\n\n<ul>\n\t<li>换句话说，令 <code>k</code> 是 <code>nums</code> <strong>任意</strong> 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 <code>k</code> 的子数组。</li>\n</ul>\n\n<p>返回满足要求的 <strong>最长</strong> 子数组的长度。</p>\n\n<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>\n\n<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n子数组按位与运算的最大值是 3 。\n能得到此结果的最长子数组是 [3,3]，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n子数组按位与运算的最大值是 4 。 \n能得到此结果的最长子数组是 [4]，所以返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n","translatedTitle":"按位与最大的最长子数组","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int longestSubarray(int[] nums) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def longestSubarray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def longestSubarray(self, nums: List[int]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint longestSubarray(int* nums, int numsSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int LongestSubarray(int[] nums) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestSubarray = function(nums) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[]} nums\n# @return {Integer}\ndef longest_subarray(nums)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func longestSubarray(_ nums: [Int]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func longestSubarray(nums []int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def longestSubarray(nums: Array[Int]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun longestSubarray(nums: IntArray): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn longest_subarray(nums: Vec<i32>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function longestSubarray($nums) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function longestSubarray(nums: number[]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (longest-subarray nums)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec longest_subarray(Nums :: [integer()]) -> integer().\nlongest_subarray(Nums) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec longest_subarray(nums :: [integer]) :: integer\n  def longest_subarray(nums) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"class Solution {\n  int longestSubarray(List<int> nums) {\n\n  }\n}"}]}