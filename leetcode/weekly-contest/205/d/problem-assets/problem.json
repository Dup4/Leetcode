{"slug":"remove-max-number-of-edges-to-keep-graph-fully-traversable","id":1701,"title":"Remove Max Number of Edges to Keep Graph Fully Traversable","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":127,"dislikes":0,"status":2,"tag":[{"name":"Union Find","slug":"union-find","translatedName":"并查集"},{"name":"Graph","slug":"graph","translatedName":"图"}],"totalAccepted":16519,"totalSubmission":26695,"hints":["Build the network instead of removing extra edges.","Suppose you have the final graph (after removing extra edges). Consider the subgraph with only the edges that Alice can traverse. What structure does this subgraph have? How many edges are there?","Use disjoint set union data structure for both Alice and Bob.","Always use Type 3 edges first, and connect the still isolated ones using other edges."],"sampleTestCase":"4\n[[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]","exampleTestcases":"4\n[[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n4\n[[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n4\n[[3,2,3],[1,1,2],[2,3,4]]","content":"<p>Alice and Bob have an undirected graph of&nbsp;<code>n</code>&nbsp;nodes&nbsp;and 3 types of edges:</p>\n\n<ul>\n\t<li>Type 1: Can be traversed by Alice only.</li>\n\t<li>Type 2: Can be traversed by Bob only.</li>\n\t<li>Type 3: Can by traversed by both Alice and Bob.</li>\n</ul>\n\n<p>Given an array&nbsp;<code>edges</code>&nbsp;where&nbsp;<code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;represents a bidirectional edge of type&nbsp;<code>type<sub>i</sub></code>&nbsp;between nodes&nbsp;<code>u<sub>i</sub></code>&nbsp;and&nbsp;<code>v<sub>i</sub></code>, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.</p>\n\n<p>Return <em>the maximum number of edges you can remove, or return</em> <code>-1</code> <em>if it&#39;s impossible for the graph to be fully traversed by Alice and Bob.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-08-19-ex1.png\" style=\"width: 179px; height: 191px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-08-19-ex2.png\" style=\"width: 178px; height: 190px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-08-19-ex3.png\" style=\"width: 178px; height: 190px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n<strong>Output:</strong> -1\n<b>Explanation: </b>In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it&#39;s impossible to make the graph fully traversable.</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 &lt;= edges[i][0] &lt;= 3</code></li>\n\t<li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li>\n\t<li>All tuples&nbsp;<code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code>&nbsp;are distinct.</li>\n</ul>\n","translatedContent":"<p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3&nbsp; 种类型的边：</p>\n\n<ul>\n\t<li>类型 1：只能由 Alice 遍历。</li>\n\t<li>类型 2：只能由 Bob 遍历。</li>\n\t<li>类型 3：Alice 和 Bob 都可以遍历。</li>\n</ul>\n\n<p>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在类型为 <code>type<sub>i</sub></code> 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p>\n\n<p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-09-06-5510ex1.png\" style=\"height: 191px; width: 179px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删除<strong> </strong>[1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-09-06-5510ex2.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-09-06-5510ex3.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 &lt;= edges[i][0] &lt;= 3</code></li>\n\t<li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li>\n\t<li>所有元组 <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> 互不相同</li>\n</ul>\n","translatedTitle":"保证图可完全遍历","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int maxNumEdgesToRemove(int n, int[][] edges) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def maxNumEdgesToRemove(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint maxNumEdgesToRemove(int n, int** edges, int edgesSize, int* edgesColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MaxNumEdgesToRemove(int n, int[][] edges) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nvar maxNumEdgesToRemove = function(n, edges) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer}\ndef max_num_edges_to_remove(n, edges)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func maxNumEdgesToRemove(_ n: Int, _ edges: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func maxNumEdgesToRemove(n int, edges [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def maxNumEdgesToRemove(n: Int, edges: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun maxNumEdgesToRemove(n: Int, edges: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn max_num_edges_to_remove(n: i32, edges: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer\n     */\n    function maxNumEdgesToRemove($n, $edges) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function maxNumEdgesToRemove(n: number, edges: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (max-num-edges-to-remove n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec max_num_edges_to_remove(N :: integer(), Edges :: [[integer()]]) -> integer().\nmax_num_edges_to_remove(N, Edges) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec max_num_edges_to_remove(n :: integer, edges :: [[integer]]) :: integer\n  def max_num_edges_to_remove(n, edges) do\n\n  end\nend"}]}