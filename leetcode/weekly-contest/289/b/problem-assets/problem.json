{"slug":"minimum-rounds-to-complete-all-tasks","id":2362,"frontendId":6071,"title":"Minimum Rounds to Complete All Tasks","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":6,"dislikes":0,"status":0,"tag":[],"totalAccepted":5994,"totalSubmission":11244,"hints":["Which data structure can you use to store the number of tasks of each difficulty level?","For any particular difficulty level, what can be the optimal strategy to complete the tasks using minimum rounds?","When can we not complete all tasks of a difficulty level?"],"sampleTestCase":"[2,2,3,3,2,4,4,4,4,4]","exampleTestcases":"[2,2,3,3,2,4,4,4,4,4]\n[2,3,3]","content":"<p>You are given a <strong>0-indexed</strong> integer array <code>tasks</code>, where <code>tasks[i]</code> represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the <strong>same difficulty level</strong>.</p>\n\n<p>Return <em>the <strong>minimum</strong> rounds required to complete all the tasks, or </em><code>-1</code><em> if it is not possible to complete all the tasks.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2. \n- In the second round, you complete 2 tasks of difficulty level 3. \n- In the third round, you complete 3 tasks of difficulty level 4. \n- In the fourth round, you complete 2 tasks of difficulty level 4.  \nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [2,3,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","translatedContent":"<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p>\n\n<p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>要想完成所有任务，一个可能的计划是：\n- 第一轮，完成难度级别为 2 的 3 个任务。 \n- 第二轮，完成难度级别为 3 的 2 个任务。 \n- 第三轮，完成难度级别为 4 的 3 个任务。 \n- 第四轮，完成难度级别为 4 的 2 个任务。 \n可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","translatedTitle":"完成所有任务需要的最少轮数","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int minimumRounds(vector<int>& tasks) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int minimumRounds(int[] tasks) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def minimumRounds(self, tasks):\n        \"\"\"\n        :type tasks: List[int]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def minimumRounds(self, tasks: List[int]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint minimumRounds(int* tasks, int tasksSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MinimumRounds(int[] tasks) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[]} tasks\n * @return {number}\n */\nvar minimumRounds = function(tasks) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[]} tasks\n# @return {Integer}\ndef minimum_rounds(tasks)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func minimumRounds(_ tasks: [Int]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func minimumRounds(tasks []int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def minimumRounds(tasks: Array[Int]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun minimumRounds(tasks: IntArray): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn minimum_rounds(tasks: Vec<i32>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[] $tasks\n     * @return Integer\n     */\n    function minimumRounds($tasks) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function minimumRounds(tasks: number[]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (minimum-rounds tasks)\n  (-> (listof exact-integer?) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec minimum_rounds(Tasks :: [integer()]) -> integer().\nminimum_rounds(Tasks) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec minimum_rounds(tasks :: [integer]) :: integer\n  def minimum_rounds(tasks) do\n\n  end\nend"}]}