{"slug":"maximum-trailing-zeros-in-a-cornered-path","id":2363,"frontendId":6072,"title":"Maximum Trailing Zeros in a Cornered Path","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":9,"dislikes":0,"status":0,"tag":[],"totalAccepted":2148,"totalSubmission":7916,"hints":["What actually tells us the trailing zeros of the product of a path?","It is the sum of the exponents of 2 and sum of the exponents of 5 of the prime factorizations of the numbers on that path. The smaller of the two is the answer for that path.","We can then treat each cell as the elbow point and calculate the largest minimum (sum of 2 exponents, sum of 5 exponents) from the combination of top-left, top-right, bottom-left and bottom-right.","To do this efficiently, we should use the prefix sum technique."],"sampleTestCase":"[[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]","exampleTestcases":"[[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n[[4,3,2],[7,6,1],[8,8,8]]","content":"<p>You are given a 2D integer array <code>grid</code> of size <code>m x n</code>, where each cell contains a positive integer.</p>\n\n<p>A <strong>cornered path</strong> is defined as a set of adjacent cells with <strong>at most</strong> one turn. More specifically, the path should exclusively move either <strong>horizontally</strong> or <strong>vertically</strong> up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the <strong>alternate</strong> direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.</p>\n\n<p>The <strong>product</strong> of a path is defined as the product of all the values in the path.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of <strong>trailing zeros</strong> in the product of a cornered path found in </em><code>grid</code>.</p>\n\n<p>Note:</p>\n\n<ul>\n\t<li><strong>Horizontal</strong> movement means moving in either the left or right direction.</li>\n\t<li><strong>Vertical</strong> movement means moving in either the up or down direction.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-03-23-ex1new2.jpg\" style=\"width: 577px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The grid on the left shows a valid cornered path.\nIt has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-03-25-ex2.jpg\" style=\"width: 150px; height: 157px;\" />\n<pre>\n<strong>Input:</strong> grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n","translatedContent":"<p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p>\n\n<p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p>\n\n<p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p>\n\n<p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li><strong>水平</strong> 移动是指向左或右移动。</li>\n\t<li><strong>竖直 </strong>移动是指向上或下移动。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-03-23-ex1new2.jpg\" style=\"width: 577px; height: 190px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>左侧的图展示了一条有效的转角路径。\n其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。\n可以证明在这条转角路径的乘积中尾随零数目最多。\n\n中间的图不是一条有效的转角路径，因为它有不止一个弯。\n右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-03-25-ex2.jpg\" style=\"width: 150px; height: 157px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格如上图所示。\n不存在乘积含尾随零的转角路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n","translatedTitle":"转角路径的乘积中最多能有几个尾随零","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int maxTrailingZeros(vector<vector<int>>& grid) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int maxTrailingZeros(int[][] grid) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def maxTrailingZeros(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def maxTrailingZeros(self, grid: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint maxTrailingZeros(int** grid, int gridSize, int* gridColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int MaxTrailingZeros(int[][] grid) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxTrailingZeros = function(grid) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[][]} grid\n# @return {Integer}\ndef max_trailing_zeros(grid)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func maxTrailingZeros(_ grid: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func maxTrailingZeros(grid [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def maxTrailingZeros(grid: Array[Array[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun maxTrailingZeros(grid: Array<IntArray>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn max_trailing_zeros(grid: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function maxTrailingZeros($grid) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function maxTrailingZeros(grid: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (max-trailing-zeros grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec max_trailing_zeros(Grid :: [[integer()]]) -> integer().\nmax_trailing_zeros(Grid) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec max_trailing_zeros(grid :: [[integer]]) :: integer\n  def max_trailing_zeros(grid) do\n\n  end\nend"}]}