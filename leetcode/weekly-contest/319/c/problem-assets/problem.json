{"slug":"minimum-number-of-operations-to-sort-a-binary-tree-by-level","id":2558,"frontendId":6235,"title":"Minimum Number of Operations to Sort a Binary Tree by Level","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":0,"dislikes":0,"status":2,"tag":[],"totalAccepted":2528,"totalSubmission":5621,"hints":["We can group the values level by level and solve each group independently.","Do BFS to group the value level by level.","Find the minimum number of swaps to sort the array of each level.","While iterating over the array, check the current element, and if not in the correct index, replace that element with the index of the element which should have come."],"sampleTestCase":"[1,4,3,7,6,8,5,null,null,null,null,9,null,10]","exampleTestcases":"[1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n[1,3,2,7,6,5,4]\n[1,2,3,4,5,6]","content":"<p>You are given the <code>root</code> of a binary tree with <strong>unique values</strong>.</p>\n\n<p>In one operation, you can choose any two nodes <strong>at the same level</strong> and swap their values.</p>\n\n<p>Return <em>the minimum number of operations needed to make the values at each level sorted in a <strong>strictly increasing order</strong></em>.</p>\n\n<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node<em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-18-image-20220918174006-2.png\" style=\"width: 500px; height: 324px;\" />\n<pre>\n<strong>Input:</strong> root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- Swap 4 and 3. The 2<sup>nd</sup> level becomes [3,4].\n- Swap 7 and 5. The 3<sup>rd</sup> level becomes [5,6,8,7].\n- Swap 8 and 7. The 3<sup>rd</sup> level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-18-image-20220918174026-3.png\" style=\"width: 400px; height: 303px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,7,6,5,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- Swap 3 and 2. The 2<sup>nd</sup> level becomes [2,3].\n- Swap 7 and 4. The 3<sup>rd</sup> level becomes [4,6,5,7].\n- Swap 6 and 5. The 3<sup>rd</sup> level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-18-image-20220918174052-4.png\" style=\"width: 400px; height: 274px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Each level is already sorted in increasing order so return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>All the values of the tree are <strong>unique</strong>.</li>\n</ul>\n","translatedContent":"<p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>\n\n<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>\n\n<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>\n\n<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n<img src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-18-image-20220918174006-2.png\" style=\"width: 500px; height: 324px;\">\n<pre><strong>输入：</strong>root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- 交换 4 和 3 。第 2 层变为 [3,4] 。\n- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。\n- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。\n共计用了 3 步操作，所以返回 3 。\n可以证明 3 是需要的最少操作数目。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n<img src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-18-image-20220918174026-3.png\" style=\"width: 400px; height: 303px;\">\n<pre><strong>输入：</strong>root = [1,3,2,7,6,5,4]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>- 交换 3 和 2 。第 2 层变为 [2,3] 。 \n- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 \n- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。\n共计用了 3 步操作，所以返回 3 。 \n可以证明 3 是需要的最少操作数目。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n<img src=\"problem-assets/https:--assets.leetcode.com-uploads-2022-09-18-image-20220918174052-4.png\" style=\"width: 400px; height: 274px;\">\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>0\n<strong>解释：</strong>每一层已经按递增顺序排序，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n</ul>\n","translatedTitle":"逐层排序二叉树所需的最少操作数目","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minimumOperations(TreeNode* root) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minimumOperations(TreeNode root) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minimumOperations(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:"},{"lang":"C","langSlug":"c","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint minimumOperations(struct TreeNode* root){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MinimumOperations(TreeNode root) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minimumOperations = function(root) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef minimum_operations(root)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func minimumOperations(_ root: TreeNode?) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minimumOperations(root *TreeNode) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def minimumOperations(root: TreeNode): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun minimumOperations(root: TreeNode?): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function minimumOperations($root) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction minimumOperations(root: TreeNode | null): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (minimum-operations root)\n  (-> (or/c tree-node? #f) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec minimum_operations(Root :: #tree_node{} | null) -> integer().\nminimum_operations(Root) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec minimum_operations(root :: TreeNode.t | nil) :: integer\n  def minimum_operations(root) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int minimumOperations(TreeNode? root) {\n\n  }\n}"}]}