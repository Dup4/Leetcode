{"slug":"minimum-cost-to-connect-two-groups-of-points","id":1717,"title":"Minimum Cost to Connect Two Groups of Points","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":49,"dislikes":0,"status":2,"tag":[{"name":"Bit Manipulation","slug":"bit-manipulation","translatedName":"位运算"},{"name":"Array","slug":"array","translatedName":"数组"},{"name":"Dynamic Programming","slug":"dynamic-programming","translatedName":"动态规划"},{"name":"Bitmask","slug":"bitmask","translatedName":"状态压缩"},{"name":"Matrix","slug":"matrix","translatedName":"矩阵"}],"totalAccepted":2031,"totalSubmission":4315,"hints":["Each point on the left would either be connected to exactly point already connected to some left node, or a subset of the nodes on the right which are not connected to any node","Use dynamic programming with bitmasking, where the state will be (number of points assigned in first group, bitmask of points assigned in second group)."],"sampleTestCase":"[[15,96],[36,2]]","exampleTestcases":"[[15,96],[36,2]]\n[[1,3,5],[4,1,1],[1,5,3]]\n[[2,5,1],[3,4,7],[8,1,2],[6,2,4],[3,8,8]]","content":"<p>You are given two groups of points where the first group has <code>size<sub>1</sub></code> points, the second group has <code>size<sub>2</sub></code> points, and <code>size<sub>1</sub> &gt;= size<sub>2</sub></code>.</p>\n\n<p>The <code>cost</code> of the connection between any two points are given in an <code>size<sub>1</sub> x size<sub>2</sub></code> matrix where <code>cost[i][j]</code> is the cost of connecting point <code>i</code> of the first group and point <code>j</code> of the second group. The groups are connected if <strong>each point in both groups is connected to one or more points in the opposite group</strong>. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.</p>\n\n<p>Return <em>the minimum cost it takes to connect the two groups</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-09-03-ex1.jpg\" style=\"width: 322px; height: 243px;\" />\n<pre>\n<strong>Input:</strong> cost = [[15, 96], [36, 2]]\n<strong>Output:</strong> 17\n<strong>Explanation</strong>: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-09-03-ex2.jpg\" style=\"width: 322px; height: 403px;\" />\n<pre>\n<strong>Input:</strong> cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>Output:</strong> 4\n<strong>Explanation</strong>: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;= size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n","translatedContent":"<p>给你两组点，其中第一组中有 <code>size<sub>1</sub></code> 个点，第二组中有 <code>size<sub>2</sub></code> 个点，且 <code>size<sub>1</sub> &gt;= size<sub>2</sub></code> 。</p>\n\n<p>任意两点间的连接成本 <code>cost</code> 由大小为 <code>size<sub>1</sub> x size<sub>2</sub></code> 矩阵给出，其中 <code>cost[i][j]</code> 是第一组中的点 <code>i</code> 和第二组中的点 <code>j</code> 的连接成本。<strong>如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。</strong>换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p>\n\n<p>返回连通两组点所需的最小成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-09-20-ex1.jpg\" style=\"height: 243px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[15, 96], [36, 2]]\n<strong>输出：</strong>17\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n总成本为 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-09-20-ex2.jpg\" style=\"height: 403px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n2--C\n3--A\n最小成本为 4 。\n请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>输出：</strong>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;=&nbsp;size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n","translatedTitle":"连通两组点的最小成本","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    int connectTwoGroups(vector<vector<int>>& cost) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int connectTwoGroups(List<List<Integer>> cost) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def connectTwoGroups(self, cost):\n        \"\"\"\n        :type cost: List[List[int]]\n        :rtype: int\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:"},{"lang":"C","langSlug":"c","code":"\n\nint connectTwoGroups(int** cost, int costSize, int* costColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int ConnectTwoGroups(IList<IList<int>> cost) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[][]} cost\n * @return {number}\n */\nvar connectTwoGroups = function(cost) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[][]} cost\n# @return {Integer}\ndef connect_two_groups(cost)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func connectTwoGroups(_ cost: [[Int]]) -> Int {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func connectTwoGroups(cost [][]int) int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def connectTwoGroups(cost: List[List[Int]]): Int = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun connectTwoGroups(cost: List<List<Int>>): Int {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[][] $cost\n     * @return Integer\n     */\n    function connectTwoGroups($cost) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function connectTwoGroups(cost: number[][]): number {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (connect-two-groups cost)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec connect_two_groups(Cost :: [[integer()]]) -> integer().\nconnect_two_groups(Cost) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec connect_two_groups(cost :: [[integer]]) :: integer\n  def connect_two_groups(cost) do\n\n  end\nend"}]}