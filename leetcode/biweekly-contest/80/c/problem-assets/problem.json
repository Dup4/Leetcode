{"slug":"match-substring-after-replacement","id":2393,"frontendId":6097,"title":"Match Substring After Replacement","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":2,"dislikes":0,"status":2,"tag":[],"totalAccepted":1947,"totalSubmission":4914,"hints":["Enumerate all substrings of s with the same length as sub, and compare each substring to sub for equality.","How can you quickly tell if a character of s can result from replacing the corresponding character in sub?"],"sampleTestCase":"\"fool3e7bar\"\n\"leet\"\n[[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]","exampleTestcases":"\"fool3e7bar\"\n\"leet\"\n[[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]\n\"fooleetbar\"\n\"f00l\"\n[[\"o\",\"0\"]]\n\"Fool33tbaR\"\n\"leetd\"\n[[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]","content":"<p>You are given two strings <code>s</code> and <code>sub</code>. You are also given a 2D character array <code>mappings</code> where <code>mappings[i] = [old<sub>i</sub>, new<sub>i</sub>]</code> indicates that you may <strong>replace</strong> any number of <code>old<sub>i</sub></code> characters of <code>sub</code> with <code>new<sub>i</sub></code>. Each character in <code>sub</code> <strong>cannot</strong> be replaced more than once.</p>\n\n<p>Return <code>true</code><em> if it is possible to make </em><code>sub</code><em> a substring of </em><code>s</code><em> by replacing zero or more characters according to </em><code>mappings</code>. Otherwise, return <code>false</code>.</p>\n\n<p>A <strong>substring</strong> is a contiguous non-empty sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;fool3e7bar&quot;, sub = &quot;leet&quot;, mappings = [[&quot;e&quot;,&quot;3&quot;],[&quot;t&quot;,&quot;7&quot;],[&quot;t&quot;,&quot;8&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Replace the first &#39;e&#39; in sub with &#39;3&#39; and &#39;t&#39; in sub with &#39;7&#39;.\nNow sub = &quot;l3e7&quot; is a substring of s, so we return true.</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;fooleetbar&quot;, sub = &quot;f00l&quot;, mappings = [[&quot;o&quot;,&quot;0&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The string &quot;f00l&quot; is not a substring of s and no replacements can be made.\nNote that we cannot replace &#39;0&#39; with &#39;o&#39;.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Fool33tbaR&quot;, sub = &quot;leetd&quot;, mappings = [[&quot;e&quot;,&quot;3&quot;],[&quot;t&quot;,&quot;7&quot;],[&quot;t&quot;,&quot;8&quot;],[&quot;d&quot;,&quot;b&quot;],[&quot;p&quot;,&quot;b&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Replace the first and second &#39;e&#39; in sub with &#39;3&#39; and &#39;d&#39; in sub with &#39;b&#39;.\nNow sub = &quot;l33tb&quot; is a substring of s, so we return true.\n\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= mappings.length &lt;= 1000</code></li>\n\t<li><code>mappings[i].length == 2</code></li>\n\t<li><code>old<sub>i</sub> != new<sub>i</sub></code></li>\n\t<li><code>s</code> and <code>sub</code> consist of uppercase and lowercase English letters and digits.</li>\n\t<li><code>old<sub>i</sub></code> and <code>new<sub>i</sub></code> are either uppercase or lowercase English letters or digits.</li>\n</ul>\n","translatedContent":"<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>sub</code>&nbsp;。同时给你一个二维字符数组&nbsp;<code>mappings</code> ，其中&nbsp;<code>mappings[i] = [old<sub>i</sub>, new<sub>i</sub>]</code>&nbsp;表示你可以替换 <code>sub</code>&nbsp;中任意数目的&nbsp;<code>old<sub>i</sub></code>&nbsp;个字符，替换成&nbsp;<code>new<sub>i</sub></code>&nbsp;。<code>sub</code>&nbsp;中每个字符 <b>不能</b>&nbsp;被替换超过一次。</p>\n\n<p>如果使用 <code>mappings</code>&nbsp;替换 0 个或者若干个字符，可以将 <code>sub</code>&nbsp;变成 <code>s</code>&nbsp;的一个子字符串，请你返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是字符串中连续非空的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]\n<b>输出：</b>true\n<b>解释：</b>将 sub 中第一个 'e' 用 '3' 替换，将 't' 用 '7' 替换。\n现在 sub = \"l3e7\" ，它是 s 的子字符串，所以我们返回 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]\n<b>输出：</b>false\n<b>解释：</b>字符串 \"f00l\" 不是 s 的子串且没有可以进行的修改。\n注意我们不能用 'o' 替换 '0' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]\n<b>输出：</b>true\n<b>解释：</b>将 sub 里第一个和第二个 'e' 用 '3' 替换，用 'b' 替换 sub 里的 'd' 。\n得到 sub = \"l33tb\" ，它是 s 的子字符串，所以我们返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= mappings.length &lt;= 1000</code></li>\n\t<li><code>mappings[i].length == 2</code></li>\n\t<li><code>old<sub>i</sub> != new<sub>i</sub></code></li>\n\t<li><code>s</code> 和&nbsp;<code>sub</code>&nbsp;只包含大写和小写英文字母和数字。</li>\n\t<li><code>old<sub>i</sub></code> 和&nbsp;<code>new<sub>i</sub></code>&nbsp;是大写、小写字母或者是个数字。</li>\n</ul>\n","translatedTitle":"替换字符后匹配","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    bool matchReplacement(string s, string sub, vector<vector<char>>& mappings) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public boolean matchReplacement(String s, String sub, char[][] mappings) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def matchReplacement(self, s, sub, mappings):\n        \"\"\"\n        :type s: str\n        :type sub: str\n        :type mappings: List[List[str]]\n        :rtype: bool\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:"},{"lang":"C","langSlug":"c","code":"\n\nbool matchReplacement(char * s, char * sub, char** mappings, int mappingsSize, int* mappingsColSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public bool MatchReplacement(string s, string sub, char[][] mappings) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {string} s\n * @param {string} sub\n * @param {character[][]} mappings\n * @return {boolean}\n */\nvar matchReplacement = function(s, sub, mappings) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {String} s\n# @param {String} sub\n# @param {Character[][]} mappings\n# @return {Boolean}\ndef match_replacement(s, sub, mappings)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func matchReplacement(_ s: String, _ sub: String, _ mappings: [[Character]]) -> Bool {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func matchReplacement(s string, sub string, mappings [][]byte) bool {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def matchReplacement(s: String, sub: String, mappings: Array[Array[Char]]): Boolean = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun matchReplacement(s: String, sub: String, mappings: Array<CharArray>): Boolean {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn match_replacement(s: String, sub: String, mappings: Vec<Vec<char>>) -> bool {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param String $s\n     * @param String $sub\n     * @param String[][] $mappings\n     * @return Boolean\n     */\n    function matchReplacement($s, $sub, $mappings) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function matchReplacement(s: string, sub: string, mappings: string[][]): boolean {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (match-replacement s sub mappings)\n  (-> string? string? (listof (listof char?)) boolean?)\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec match_replacement(S :: unicode:unicode_binary(), Sub :: unicode:unicode_binary(), Mappings :: [[char()]]) -> boolean().\nmatch_replacement(S, Sub, Mappings) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec match_replacement(s :: String.t, sub :: String.t, mappings :: [[char]]) :: boolean\n  def match_replacement(s, sub, mappings) do\n\n  end\nend"}]}