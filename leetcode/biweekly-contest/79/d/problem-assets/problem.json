{"slug":"booking-concert-tickets-in-groups","id":2380,"frontendId":10011,"title":"Booking Concert Tickets in Groups","categoryTitle":"Algorithms","difficulty":2,"starred":false,"locked":false,"likes":0,"dislikes":0,"status":2,"tag":[],"totalAccepted":719,"totalSubmission":6794,"hints":["Since seats are allocated by smallest row and then by smallest seat numbers, how can we keep a record of the smallest seat number vacant in each row?","How can range max query help us to check if contiguous seats can be allocated in a range?","Similarly, can range sum query help us to check if enough seats are available in a range?","Which data structure can be used to implement the above?"],"sampleTestCase":"[\"BookMyShow\",\"gather\",\"gather\",\"scatter\",\"scatter\"]\n[[2,5],[4,0],[2,0],[5,1],[5,1]]","exampleTestcases":"[\"BookMyShow\",\"gather\",\"gather\",\"scatter\",\"scatter\"]\n[[2,5],[4,0],[2,0],[5,1],[5,1]]","content":"<p>A concert hall has <code>n</code> rows numbered from <code>0</code> to <code>n - 1</code>, each with <code>m</code> seats, numbered from <code>0</code> to <code>m - 1</code>. You need to design a ticketing system that can allocate seats in the following cases:</p>\n\n<ul>\n\t<li>If a group of <code>k</code> spectators can sit <strong>together</strong> in a row.</li>\n\t<li>If <strong>every</strong> member of a group of <code>k</code> spectators can get a seat. They may or <strong>may not</strong> sit together.</li>\n</ul>\n\n<p>Note that the spectators are very picky. Hence:</p>\n\n<ul>\n\t<li>They will book seats only if each member of their group can get a seat with row number <strong>less than or equal</strong> to <code>maxRow</code>. <code>maxRow</code> can <strong>vary</strong> from group to group.</li>\n\t<li>In case there are multiple rows to choose from, the row with the <strong>smallest</strong> number is chosen. If there are multiple seats to choose in the same row, the seat with the <strong>smallest</strong> number is chosen.</li>\n</ul>\n\n<p>Implement the <code>BookMyShow</code> class:</p>\n\n<ul>\n\t<li><code>BookMyShow(int n, int m)</code> Initializes the object with <code>n</code> as number of rows and <code>m</code> as number of seats per row.</li>\n\t<li><code>int[] gather(int k, int maxRow)</code> Returns an array of length <code>2</code> denoting the row and seat number (respectively) of the <strong>first seat</strong> being allocated to the <code>k</code> members of the group, who must sit <strong>together</strong>. In other words, it returns the smallest possible <code>r</code> and <code>c</code> such that all <code>[c, c + k - 1]</code> seats are valid and empty in row <code>r</code>, and <code>r &lt;= maxRow</code>. Returns <code>[]</code> in case it is <strong>not possible</strong> to allocate seats to the group.</li>\n\t<li><code>boolean scatter(int k, int maxRow)</code> Returns <code>true</code> if all <code>k</code> members of the group can be allocated seats in rows <code>0</code> to <code>maxRow</code>, who may or <strong>may not</strong> sit together. If the seats can be allocated, it allocates <code>k</code> seats to the group with the <strong>smallest</strong> row numbers, and the smallest possible seat numbers in each row. Otherwise, returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;BookMyShow&quot;, &quot;gather&quot;, &quot;gather&quot;, &quot;scatter&quot;, &quot;scatter&quot;]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n<strong>Output</strong>\n[null, [0, 0], [], true, false]\n\n<strong>Explanation</strong>\nBookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each \nbms.gather(4, 0); // return [0, 0]\n                  // The group books seats [0, 3] of row 0. \nbms.gather(2, 0); // return []\n                  // There is only 1 seat left in row 0,\n                  // so it is not possible to book 2 consecutive seats. \nbms.scatter(5, 1); // return True\n                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. \nbms.scatter(5, 1); // return False\n                   // There are only 2 seats left in the hall.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>gather</code> and <code>scatter</code>.</li>\n</ul>\n","translatedContent":"<p>一个音乐会总共有&nbsp;<code>n</code>&nbsp;排座位，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每一排有&nbsp;<code>m</code>&nbsp;个座椅，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>m - 1</code>&nbsp;。你需要设计一个买票系统，针对以下情况进行座位安排：</p>\n\n<ul>\n\t<li>同一组的 <code>k</code>&nbsp;位观众坐在<strong> 同一排座位，且座位连续 </strong>。</li>\n\t<li><code>k</code>&nbsp;位观众中 <strong>每一位</strong>&nbsp;都有座位坐，但他们 <strong>不一定</strong>&nbsp;坐在一起。</li>\n</ul>\n\n<p>由于观众非常挑剔，所以：</p>\n\n<ul>\n\t<li>只有当一个组里所有成员座位的排数都 <strong>小于等于</strong>&nbsp;<code>maxRow</code>&nbsp;，这个组才能订座位。每一组的&nbsp;<code>maxRow</code>&nbsp;可能 <strong>不同</strong>&nbsp;。</li>\n\t<li>如果有多排座位可以选择，优先选择 <strong>最小</strong>&nbsp;的排数。如果同一排中有多个座位可以坐，优先选择号码 <strong>最小</strong>&nbsp;的。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>BookMyShow</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>BookMyShow(int n, int m)</code>&nbsp;，初始化对象，<code>n</code>&nbsp;是排数，<code>m</code>&nbsp;是每一排的座位数。</li>\n\t<li><code>int[] gather(int k, int maxRow)</code>&nbsp;返回长度为 <code>2</code>&nbsp;的数组，表示 <code>k</code>&nbsp;个成员中 <strong>第一个座位</strong>&nbsp;的排数和座位编号，这 <code>k</code>&nbsp;位成员必须坐在 <strong>同一排座位，且座位连续 </strong>。换言之，返回最小可能的&nbsp;<code>r</code> 和&nbsp;<code>c</code>&nbsp;满足第&nbsp;<code>r</code>&nbsp;排中&nbsp;<code>[c, c + k - 1]</code>&nbsp;的座位都是空的，且&nbsp;<code>r &lt;= maxRow</code>&nbsp;。如果&nbsp;<strong>无法</strong>&nbsp;安排座位，返回&nbsp;<code>[]</code>&nbsp;。</li>\n\t<li><code>boolean scatter(int k, int maxRow)</code>&nbsp;如果组里所有&nbsp;<code>k</code>&nbsp;个成员&nbsp;<strong>不一定</strong>&nbsp;要坐在一起的前提下，都能在第&nbsp;<code>0</code> 排到第&nbsp;<code>maxRow</code>&nbsp;排之间找到座位，那么请返回&nbsp;<code>true</code>&nbsp;。这种情况下，每个成员都优先找排数&nbsp;<strong>最小</strong>&nbsp;，然后是座位编号最小的座位。如果不能安排所有&nbsp;<code>k</code>&nbsp;个成员的座位，请返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n<strong>输出：</strong>\n[null, [0, 0], [], true, false]\n\n<strong>解释：</strong>\nBookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。\nbms.gather(4, 0); // 返回 [0, 0]\n                  // 这一组安排第 0 排 [0, 3] 的座位。\nbms.gather(2, 0); // 返回 []\n                  // 第 0 排只剩下 1 个座位。\n                  // 所以无法安排 2 个连续座位。\nbms.scatter(5, 1); // 返回 True\n                   // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。\nbms.scatter(5, 1); // 返回 False\n                   // 总共只剩下 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>\n\t<li><code>gather</code> 和&nbsp;<code>scatter</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>5 * 10<sup>4</sup></code> 次。</li>\n</ul>\n","translatedTitle":"以组为单位订音乐会的门票","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class BookMyShow {\npublic:\n    BookMyShow(int n, int m) {\n\n    }\n    \n    vector<int> gather(int k, int maxRow) {\n\n    }\n    \n    bool scatter(int k, int maxRow) {\n\n    }\n};\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow* obj = new BookMyShow(n, m);\n * vector<int> param_1 = obj->gather(k,maxRow);\n * bool param_2 = obj->scatter(k,maxRow);\n */"},{"lang":"Java","langSlug":"java","code":"class BookMyShow {\n\n    public BookMyShow(int n, int m) {\n\n    }\n    \n    public int[] gather(int k, int maxRow) {\n\n    }\n    \n    public boolean scatter(int k, int maxRow) {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = new BookMyShow(n, m);\n * int[] param_1 = obj.gather(k,maxRow);\n * boolean param_2 = obj.scatter(k,maxRow);\n */"},{"lang":"Python","langSlug":"python","code":"class BookMyShow(object):\n\n    def __init__(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        \"\"\"\n\n\n    def gather(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: List[int]\n        \"\"\"\n\n\n    def scatter(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: bool\n        \"\"\"\n\n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"},{"lang":"Python3","langSlug":"python3","code":"class BookMyShow:\n\n    def __init__(self, n: int, m: int):\n\n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n\n\n    def scatter(self, k: int, maxRow: int) -> bool:\n\n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"},{"lang":"C","langSlug":"c","code":"\n\n\ntypedef struct {\n\n} BookMyShow;\n\n\nBookMyShow* bookMyShowCreate(int n, int m) {\n\n}\n\nint* bookMyShowGather(BookMyShow* obj, int k, int maxRow, int* retSize) {\n\n}\n\nbool bookMyShowScatter(BookMyShow* obj, int k, int maxRow) {\n\n}\n\nvoid bookMyShowFree(BookMyShow* obj) {\n\n}\n\n/**\n * Your BookMyShow struct will be instantiated and called as such:\n * BookMyShow* obj = bookMyShowCreate(n, m);\n * int* param_1 = bookMyShowGather(obj, k, maxRow, retSize);\n \n * bool param_2 = bookMyShowScatter(obj, k, maxRow);\n \n * bookMyShowFree(obj);\n*/"},{"lang":"C#","langSlug":"csharp","code":"public class BookMyShow {\n\n    public BookMyShow(int n, int m) {\n\n    }\n    \n    public int[] Gather(int k, int maxRow) {\n\n    }\n    \n    public bool Scatter(int k, int maxRow) {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = new BookMyShow(n, m);\n * int[] param_1 = obj.Gather(k,maxRow);\n * bool param_2 = obj.Scatter(k,maxRow);\n */"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number} n\n * @param {number} m\n */\nvar BookMyShow = function(n, m) {\n\n};\n\n/** \n * @param {number} k \n * @param {number} maxRow\n * @return {number[]}\n */\nBookMyShow.prototype.gather = function(k, maxRow) {\n\n};\n\n/** \n * @param {number} k \n * @param {number} maxRow\n * @return {boolean}\n */\nBookMyShow.prototype.scatter = function(k, maxRow) {\n\n};\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"},{"lang":"Ruby","langSlug":"ruby","code":"class BookMyShow\n\n=begin\n    :type n: Integer\n    :type m: Integer\n=end\n    def initialize(n, m)\n\n    end\n\n\n=begin\n    :type k: Integer\n    :type max_row: Integer\n    :rtype: Integer[]\n=end\n    def gather(k, max_row)\n\n    end\n\n\n=begin\n    :type k: Integer\n    :type max_row: Integer\n    :rtype: Boolean\n=end\n    def scatter(k, max_row)\n\n    end\n\n\nend\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow.new(n, m)\n# param_1 = obj.gather(k, max_row)\n# param_2 = obj.scatter(k, max_row)"},{"lang":"Swift","langSlug":"swift","code":"\nclass BookMyShow {\n\n    init(_ n: Int, _ m: Int) {\n\n    }\n    \n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\n\n    }\n    \n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj = BookMyShow(n, m)\n * let ret_1: [Int] = obj.gather(k, maxRow)\n * let ret_2: Bool = obj.scatter(k, maxRow)\n */"},{"lang":"Go","langSlug":"golang","code":"type BookMyShow struct {\n\n}\n\n\nfunc Constructor(n int, m int) BookMyShow {\n\n}\n\n\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\n\n}\n\n\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\n\n}\n\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * obj := Constructor(n, m);\n * param_1 := obj.Gather(k,maxRow);\n * param_2 := obj.Scatter(k,maxRow);\n */"},{"lang":"Scala","langSlug":"scala","code":"class BookMyShow(_n: Int, _m: Int) {\n\n    def gather(k: Int, maxRow: Int): Array[Int] = {\n\n    }\n\n    def scatter(k: Int, maxRow: Int): Boolean = {\n\n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"},{"lang":"Kotlin","langSlug":"kotlin","code":"class BookMyShow(n: Int, m: Int) {\n\n    fun gather(k: Int, maxRow: Int): IntArray {\n\n    }\n\n    fun scatter(k: Int, maxRow: Int): Boolean {\n\n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"},{"lang":"Rust","langSlug":"rust","code":"struct BookMyShow {\n\n}\n\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BookMyShow {\n\n    fn new(n: i32, m: i32) -> Self {\n\n    }\n    \n    fn gather(&self, k: i32, max_row: i32) -> Vec<i32> {\n\n    }\n    \n    fn scatter(&self, k: i32, max_row: i32) -> bool {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj = BookMyShow::new(n, m);\n * let ret_1: Vec<i32> = obj.gather(k, maxRow);\n * let ret_2: bool = obj.scatter(k, maxRow);\n */"},{"lang":"PHP","langSlug":"php","code":"class BookMyShow {\n    /**\n     * @param Integer $n\n     * @param Integer $m\n     */\n    function __construct($n, $m) {\n\n    }\n\n    /**\n     * @param Integer $k\n     * @param Integer $maxRow\n     * @return Integer[]\n     */\n    function gather($k, $maxRow) {\n\n    }\n\n    /**\n     * @param Integer $k\n     * @param Integer $maxRow\n     * @return Boolean\n     */\n    function scatter($k, $maxRow) {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * $obj = BookMyShow($n, $m);\n * $ret_1 = $obj->gather($k, $maxRow);\n * $ret_2 = $obj->scatter($k, $maxRow);\n */"},{"lang":"TypeScript","langSlug":"typescript","code":"class BookMyShow {\n    constructor(n: number, m: number) {\n\n    }\n\n    gather(k: number, maxRow: number): number[] {\n\n    }\n\n    scatter(k: number, maxRow: number): boolean {\n\n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"},{"lang":"Racket","langSlug":"racket","code":"(define book-my-show%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; m : exact-integer?\n    (init-field\n      n\n      m)\n    \n    ; gather : exact-integer? exact-integer? -> (listof exact-integer?)\n    (define/public (gather k max-row)\n\n      )\n    ; scatter : exact-integer? exact-integer? -> boolean?\n    (define/public (scatter k max-row)\n\n      )))\n\n;; Your book-my-show% object will be instantiated and called as such:\n;; (define obj (new book-my-show% [n n] [m m]))\n;; (define param_1 (send obj gather k max-row))\n;; (define param_2 (send obj scatter k max-row))"},{"lang":"Erlang","langSlug":"erlang","code":"-spec book_my_show_init_(N :: integer(), M :: integer()) -> any().\nbook_my_show_init_(N, M) ->\n  .\n\n-spec book_my_show_gather(K :: integer(), MaxRow :: integer()) -> [integer()].\nbook_my_show_gather(K, MaxRow) ->\n  .\n\n-spec book_my_show_scatter(K :: integer(), MaxRow :: integer()) -> boolean().\nbook_my_show_scatter(K, MaxRow) ->\n  .\n\n\n%% Your functions will be called as such:\n%% book_my_show_init_(N, M),\n%% Param_1 = book_my_show_gather(K, MaxRow),\n%% Param_2 = book_my_show_scatter(K, MaxRow),\n\n%% book_my_show_init_ will be called before every test case, in which you can do some necessary initializations."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule BookMyShow do\n  @spec init_(n :: integer, m :: integer) :: any\n  def init_(n, m) do\n\n  end\n\n  @spec gather(k :: integer, max_row :: integer) :: [integer]\n  def gather(k, max_row) do\n\n  end\n\n  @spec scatter(k :: integer, max_row :: integer) :: boolean\n  def scatter(k, max_row) do\n\n  end\nend\n\n# Your functions will be called as such:\n# BookMyShow.init_(n, m)\n# param_1 = BookMyShow.gather(k, max_row)\n# param_2 = BookMyShow.scatter(k, max_row)\n\n# BookMyShow.init_ will be called before every test case, in which you can do some necessary initializations."}]}