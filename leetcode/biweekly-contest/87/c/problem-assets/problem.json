{"slug":"smallest-subarrays-with-maximum-bitwise-or","id":2498,"frontendId":6186,"title":"Smallest Subarrays With Maximum Bitwise OR","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":0,"dislikes":0,"status":2,"tag":[],"totalAccepted":1133,"totalSubmission":4754,"hints":["Consider trying to solve the problem for each bit position separately.","For each bit position, find the position of the next number that has a 1 in that position, if any.","Take the maximum distance to such a number, including the current number.","Iterate backwards to achieve a linear complexity."],"sampleTestCase":"[1,0,2,1,3]","exampleTestcases":"[1,0,2,1,3]\n[1,2]","content":"<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>, consisting of non-negative integers. For each index <code>i</code> from <code>0</code> to <code>n - 1</code>, you must determine the size of the <strong>minimum sized</strong> non-empty subarray of <code>nums</code> starting at <code>i</code> (<strong>inclusive</strong>) that has the <strong>maximum</strong> possible <strong>bitwise OR</strong>.</p>\n\n<ul>\n\t<li>In other words, let <code>B<sub>ij</sub></code> be the bitwise OR of the subarray <code>nums[i...j]</code>. You need to find the smallest subarray starting at <code>i</code>, such that bitwise OR of this subarray is equal to <code>max(B<sub>ik</sub>)</code> where <code>i &lt;= k &lt;= n - 1</code>.</li>\n</ul>\n\n<p>The bitwise OR of an array is the bitwise OR of all the numbers in it.</p>\n\n<p>Return <em>an integer array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the length of the <strong>minimum</strong> sized subarray starting at </em><code>i</code><em> with <strong>maximum</strong> bitwise OR.</em></p>\n\n<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,2,1,3]\n<strong>Output:</strong> [3,3,2,2,1]\n<strong>Explanation:</strong>\nThe maximum possible bitwise OR starting at any index is 3. \n- Starting at index 0, the shortest subarray that yields it is [1,0,2].\n- Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1].\n- Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1].\n- Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3].\n- Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3].\nTherefore, we return [3,3,2,2,1]. \n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> [2,1]\n<strong>Explanation:\n</strong>Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2.\nStarting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1.\nTherefore, we return [2,1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","translatedContent":"<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，数组中所有数字均为非负整数。对于&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的每一个下标 <code>i</code>&nbsp;，你需要找出&nbsp;<code>nums</code>&nbsp;中一个 <strong>最小</strong> 非空子数组，它的起始位置为&nbsp;<code>i</code>&nbsp;（包含这个位置），同时有&nbsp;<strong>最大</strong>&nbsp;的 <strong>按位或</strong><b>运算值</b>&nbsp;。</p>\n\n<ul>\n\t<li>换言之，令&nbsp;<code>B<sub>ij</sub></code>&nbsp;表示子数组&nbsp;<code>nums[i...j]</code>&nbsp;的按位或运算的结果，你需要找到一个起始位置为&nbsp;<code>i</code>&nbsp;的最小子数组，这个子数组的按位或运算的结果等于&nbsp;<code>max(B<sub>ik</sub>)</code>&nbsp;，其中&nbsp;<code>i &lt;= k &lt;= n - 1</code>&nbsp;。</li>\n</ul>\n\n<p>一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</p>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是开始位置为&nbsp;<code>i</code>&nbsp;，按位或运算结果最大，且&nbsp;<strong>最短</strong>&nbsp;子数组的长度。</p>\n\n<p><strong>子数组</strong>&nbsp;是数组里一段连续非空元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,2,1,3]\n<b>输出：</b>[3,3,2,2,1]\n<strong>解释：</strong>\n任何位置开始，最大按位或运算的结果都是 3 。\n- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。\n- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。\n- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。\n- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。\n- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。\n所以我们返回 [3,3,2,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2]\n<b>输出：</b>[2,1]\n<strong>解释：\n</strong>下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。\n下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。\n所以我们返回 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","translatedTitle":"按位或最大的最小子数组长度","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    vector<int> smallestSubarrays(vector<int>& nums) {\n        \n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public int[] smallestSubarrays(int[] nums) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def smallestSubarrays(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:"},{"lang":"C","langSlug":"c","code":"\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* smallestSubarrays(int* nums, int numsSize, int* returnSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public int[] SmallestSubarrays(int[] nums) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar smallestSubarrays = function(nums) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer[]} nums\n# @return {Integer[]}\ndef smallest_subarrays(nums)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func smallestSubarrays(nums []int) []int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def smallestSubarrays(nums: Array[Int]): Array[Int] = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun smallestSubarrays(nums: IntArray): IntArray {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn smallest_subarrays(nums: Vec<i32>) -> Vec<i32> {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function smallestSubarrays($nums) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function smallestSubarrays(nums: number[]): number[] {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (smallest-subarrays nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec smallest_subarrays(Nums :: [integer()]) -> [integer()].\nsmallest_subarrays(Nums) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec smallest_subarrays(nums :: [integer]) :: [integer]\n  def smallest_subarrays(nums) do\n\n  end\nend"},{"lang":"Dart","langSlug":"dart","code":"class Solution {\n  List<int> smallestSubarrays(List<int> nums) {\n\n  }\n}"}]}