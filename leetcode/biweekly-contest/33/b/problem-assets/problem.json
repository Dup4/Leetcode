{"slug":"minimum-number-of-vertices-to-reach-all-nodes","id":1661,"title":"Minimum Number of Vertices to Reach All Nodes","categoryTitle":"Algorithms","difficulty":1,"starred":false,"locked":false,"likes":35,"dislikes":0,"status":2,"tag":[{"name":"Graph","slug":"graph","translatedName":"图"}],"totalAccepted":9707,"totalSubmission":12408,"hints":["A node that does not have any incoming edge can only be reached by itself.","Any other node with incoming edges can be reached from some other node.","We only have to count the number of nodes with zero incoming edges."],"sampleTestCase":"6\n[[0,1],[0,2],[2,5],[3,4],[4,2]]","exampleTestcases":"6\n[[0,1],[0,2],[2,5],[3,4],[4,2]]\n5\n[[0,1],[2,1],[3,1],[1,4],[2,4]]","content":"<p>Given a<strong>&nbsp;directed acyclic graph</strong>,&nbsp;with&nbsp;<code>n</code>&nbsp;vertices numbered from&nbsp;<code>0</code>&nbsp;to&nbsp;<code>n-1</code>,&nbsp;and an array&nbsp;<code>edges</code>&nbsp;where&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;represents a directed edge from node&nbsp;<code>from<sub>i</sub></code>&nbsp;to node&nbsp;<code>to<sub>i</sub></code>.</p>\r\n\r\n<p>Find <em>the smallest set of vertices from which all nodes in the graph are reachable</em>. It&#39;s guaranteed that a unique solution exists.</p>\r\n\r\n<p>Notice that you can return the vertices in any order.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-07-07-untitled22.png\" style=\"width: 231px; height: 181px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\r\n<strong>Output:</strong> [0,3]\r\n<b>Explanation: </b>It&#39;s not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode.com-uploads-2020-07-07-untitled.png\" style=\"width: 201px; height: 201px;\" /></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\r\n<strong>Output:</strong> [0,2,3]\r\n<strong>Explanation: </strong>Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\r\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>\r\n\t<li><code>edges[i].length == 2</code></li>\r\n\t<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>\r\n\t<li>All pairs <code>(from<sub>i</sub>, to<sub>i</sub>)</code> are distinct.</li>\r\n</ul>","translatedContent":"<p>给你一个 <strong>有向无环图</strong>&nbsp;， <code>n</code>&nbsp;个节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，以及一个边数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示一条从点&nbsp;&nbsp;<code>from<sub>i</sub></code>&nbsp;到点&nbsp;<code>to<sub>i</sub></code>&nbsp;的有向边。</p>\n\n<p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p>\n\n<p>你可以以任意顺序返回这些节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-08-22-5480e1.png\" style=\"height: 181px; width: 231px;\"></p>\n\n<pre><strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\n<strong>输出：</strong>[0,3]\n<strong>解释：</strong>从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"problem-assets/https:--assets.leetcode-cn.com-aliyun-lc-upload-uploads-2020-08-22-5480e2.png\" style=\"height: 201px; width: 201px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\n<strong>输出：</strong>[0,2,3]\n<strong>解释：</strong>注意到节点 0，3 和 2 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 1 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>\n\t<li>所有点对&nbsp;<code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;互不相同。</li>\n</ul>\n","translatedTitle":"可以到达所有点的最少点数目","codeSnippets":[{"lang":"C++","langSlug":"cpp","code":"class Solution {\npublic:\n    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {\n\n    }\n};"},{"lang":"Java","langSlug":"java","code":"class Solution {\n    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {\n\n    }\n}"},{"lang":"Python","langSlug":"python","code":"class Solution(object):\n    def findSmallestSetOfVertices(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\""},{"lang":"Python3","langSlug":"python3","code":"class Solution:\n    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:"},{"lang":"C","langSlug":"c","code":"\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSmallestSetOfVertices(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n\n}"},{"lang":"C#","langSlug":"csharp","code":"public class Solution {\n    public IList<int> FindSmallestSetOfVertices(int n, IList<IList<int>> edges) {\n\n    }\n}"},{"lang":"JavaScript","langSlug":"javascript","code":"/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar findSmallestSetOfVertices = function(n, edges) {\n\n};"},{"lang":"Ruby","langSlug":"ruby","code":"# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef find_smallest_set_of_vertices(n, edges)\n\nend"},{"lang":"Swift","langSlug":"swift","code":"class Solution {\n    func findSmallestSetOfVertices(_ n: Int, _ edges: [[Int]]) -> [Int] {\n\n    }\n}"},{"lang":"Go","langSlug":"golang","code":"func findSmallestSetOfVertices(n int, edges [][]int) []int {\n\n}"},{"lang":"Scala","langSlug":"scala","code":"object Solution {\n    def findSmallestSetOfVertices(n: Int, edges: List[List[Int]]): List[Int] = {\n\n    }\n}"},{"lang":"Kotlin","langSlug":"kotlin","code":"class Solution {\n    fun findSmallestSetOfVertices(n: Int, edges: List<List<Int>>): List<Int> {\n\n    }\n}"},{"lang":"Rust","langSlug":"rust","code":"impl Solution {\n    pub fn find_smallest_set_of_vertices(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n\n    }\n}"},{"lang":"PHP","langSlug":"php","code":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findSmallestSetOfVertices($n, $edges) {\n\n    }\n}"},{"lang":"TypeScript","langSlug":"typescript","code":"function findSmallestSetOfVertices(n: number, edges: number[][]): number[] {\n\n};"},{"lang":"Racket","langSlug":"racket","code":"(define/contract (find-smallest-set-of-vertices n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n\n  )"},{"lang":"Erlang","langSlug":"erlang","code":"-spec find_smallest_set_of_vertices(N :: integer(), Edges :: [[integer()]]) -> [integer()].\nfind_smallest_set_of_vertices(N, Edges) ->\n  ."},{"lang":"Elixir","langSlug":"elixir","code":"defmodule Solution do\n  @spec find_smallest_set_of_vertices(n :: integer, edges :: [[integer]]) :: [integer]\n  def find_smallest_set_of_vertices(n, edges) do\n\n  end\nend"}]}